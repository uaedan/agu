#     set NVTID = 2014.299,03:04:38.5000; echo "Trailing QUAKE"
#     set NVTID = 2014.272,16:57:10.5000; echo "Exceptionally LONG"
#     set NVTID = 2014.226,01:42:47.0000; echo "Impressively SMALL"
#                 2015.074,20:47:46.5000\ # QUAKE entrained

#D 151019:  RMN added Z0_STOP... for first Vest gp search w/ too few mnPAIR

#D      ## LINUX ##
#D      ## LINUX ##
#D      ## LINUX ##
#D  = SET-UP
#     echo "In Turn:"
#     set mkDAT = "Y"; set mkPLOTs = "N"; set vuPLOTs = "N"
#     set mkDAT = "N"; set mkPLOTs = "Y"; set vuPLOTs = "N"
#     set mkDAT = "N"; set mkPLOTs = "N"; set vuPLOTs = "Y"
#     echo "CURRENT"
#     set mkDAT = "N"; set mkPLOTs = "N"; set vuPLOTs = "Y" 
#     echo "STANDARD"
      set mkDAT = "N"; set mkPLOTs = "N"; set vuPLOTs = "Y"
      set mkDAT = "Y"; set mkPLOTs = "Y"; set vuPLOTs = "Y"
      set mkDAT = "Y"; set mkPLOTs = "Y"; set vuPLOTs = "N"

#     cd /data/hrsn1/hfn6/nadeau/PACKAGES/PSERM
      set startDIR = /home/u2/ldamiao/ncaltremor/agu
      cd "$startDIR"
      set utl = "$startDIR"/UTL
      set QUAD = PRK
      set STAGE = PSERM-PASS1
      set datDIR = /work/nct/ldamiao/agu/$QUAD/$STAGE
      mkdir -p $datDIR
      set spy2 = "source /share/apps/scl/enable_python27.csh"
      ls /data/hrsn4/nadeau/CATALOG_07/DAT.FULL-CAT/LIBERAL > /dev/null
      ln -s /data/hrsn4/nadeau/CATALOG_07/DAT.FULL-CAT/LIBERAL/ S_LIBERAL
      ln -s "$datDIR" S_"$STAGE"_"$QUAD"
      cd S_"$STAGE"_"$QUAD"
      ln -s "$startDIR" B_agu
      set catFNo = cat.dect-hrsn07_LIBRL-Amn_3.0Dmn_2001.208-2015.094.pub
      set catPTH = /data/hrsn4/nadeau/CATALOG_07/DAT.FULL-CAT/LIBERAL
      set nvtlst = l.NVTID_prk-hrsn_2014.001-2015.094

set runt00 = `date +%Y.%j,%T`

# START GRAND LOOP
# START GRAND LOOP
# START GRAND LOOP

# Get subset of NVTs
# commenting out a line means that I have confirmed that those 
# events were successfully run

#sed -n '1,$p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '1,2p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '3,4p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '5,7p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '8,10p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '11,13p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '14,14p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '15,15p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '16,16p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '17,18p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '19,20p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '21,22p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '23,24p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '25,26p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '27,28p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '29,30p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '31,35p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '36,37p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '38,43p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '44,48p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '49,50p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '51,57p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '58,58p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '59,60p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '61,65p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
### had to redo 61
#sed -n '61,61p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '66,75p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '77,86p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '87,94p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '95,96p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '97,99p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '100,110p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
##### need to go back and do 113 nvt 2014.137,02:45:13.0000
#sed -n '113,113p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '114,120p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '121,130p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
####error on 134
#sed -n '131,134p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '135,140p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
####ran 141 - 150 and 141 crashed   rerunning 142 - 150
#sed -n '141,150p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '142,150p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#### crashed on 152
#sed -n '151,160p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
##sed -n '153,160p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
sed -n '156,160p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#### crashed at 163
#sed -n '161,170p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
#sed -n '164,170p' "$startDIR"/$nvtlst > tmp.nvtlst.$$
chmod 666 tmp.nvtlst.$$


foreach NVTID (` cat tmp.nvtlst.$$ `)

      cd $datDIR
      set YD = `echo $NVTID |gawk '{printf("%04d.%03d\n",substr($0,1,4),substr($0,6,3) )}'`
      set vuPLTdir = "$datDIR/DAT_"$NVTID"/DAT.TRMD"
      mkdir DAT_"$NVTID" >& /dev/null
      cd DAT_"$NVTID"
      mkdir DAT.ORG  >& /dev/null
      cd DAT.ORG


if ( "$mkDAT" == "Y" ) then
#D    = a) Get processed WF, VLP and DETECTION data from SRCs
#D       !!! NOTE !!!: Using vlp data (not Fvlp) 
      ls "$catPTH" > /dev/null
      ln -s "$catPTH"/VLPS/"$YD" \
         S_VLPS_"$YD"
      ls $catPTH/$catFNo > /dev/null
      egrep "^$NVTID" $catPTH/$catFNo \
        > cat."$NVTID"_detect-INFO
      cp S_VLPS_"$YD"/*"$NVTID"*.vlp.ms .
      cp S_VLPS_"$YD"/*"$NVTID".ms .
   echo "# Remove zero sized files"
      ls -l *"$NVTID"*.ms  *"$NVTID"*.vlp.ms |\
        gawk '{if($5+0 == 0+0){print $NF}}' > tmp.rmv.$$
      /bin/rm `cat tmp.rmv.$$` 
      /bin/rm tmp.rmv.$$



#D    = b) Trim to 5 min before start and 5 min after end of NVT
      cd $datDIR
      cd DAT_"$NVTID"
      mkdir DAT.TRMD
      cd DAT.TRMD
      ln -s ../DAT.ORG  S_DAT.ORG
      cp S_DAT.ORG/cat."$NVTID"_detect-INFO .
      set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
      set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
      set sT = `caldate -- $nvtSTRT -5M`
      set eT = `caldate -- $nvtEND +5M`
      ls S_DAT.ORG/*"$NVTID"*.ms S_DAT.ORG/*"$NVTID"*.vlp.ms > tmp.FNs.$$
      foreach fn (` cat tmp.FNs.$$ |sed -n '1,$p' `)
        set of = `echo $fn |sed 's/.*\///' |sed 's/\.ms/\.trmd/'`
        qmerge -T -o $of -f $sT -t $eT $fn
        echo $of
      end

      
#D    = c) Convert vlp to ascii:  Combine ts's: and ptil-sort combination data
#D      + Convert vlps inst-corrct-only
#D  (OTPT: *"$NVTID"*.vlp.ascii  )
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
      ls *"$NVTID"*.vlp.trmd > tmp.FNs2.$$
      foreach fn (` cat tmp.FNs2.$$ |sed -n '1,$p' `)
        set of = `echo $fn |sed 's/\.trmd/\.ascii/'`
        qmerge -T -d 1024 $fn |egrep -v 'seq\=' > $of
        echo $of
      end


#D      + Combine vlps inst-corrct-only
#D  (OTPT: dat.vlp-combo{passtyp} )
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
      set passtyp = ""; echo "## INITIAL pass ##"
      if ( "$passtyp" == "" ) then
         echo "## INITIAL PASS ##"
         paste *"$NVTID"*.vlp.ascii > dat.vlp-combo"$passtyp"
      endif
      wc dat.vlp-combo"$passtyp"
     "$utl"/mbells

echo "A0000"


#D        -----------------------------------------------------------
#D        + Make NORMALIZED vlps 
#D           = USE ONLY DETECTION PERIOD +/ 15 sec (150 smps @ 10 sps) for normalization !!!
#D             . Already trimmed so PERIOD begins 5 min after  sT  and
#D                 ends 5 min before  eT
#D           = .normal2 ==>  V75-min normalized 
#D             + substract minimun from all (shift)
#D             + calculate Q3
#D             + divide ts by Q3 (normalization)
#D        + Combine Normalized versions
#D          . Object is to attempt to correct for inaccurate nominal instr-gains
#D    (OTPT(s): 
#D        *{NVTID}*.vlp{passtyp}.ascii
#D      and
#D        dat.vlp-combo{passtyp} )
      cd $datDIR
      set SPSvlp = 10
      cd DAT_"$NVTID"
      cd DAT.TRMD
      set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
      set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
      set dM = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$1)}'`
      set dS = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$2)}'`
      set dF = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$3)}'`
  set durSMP = `echo "$dM $dS $dF $SPSvlp" |gawk '{printf("%d",($1*60*$4)+($2*$4)+(($3/10000)*$4) )}'`
      set pmSMP = 150; echo "(15 sec at 10 sps)"
      set smpS = `echo "5. 60. $SPSvlp $pmSMP" |gawk '{printf("%d",($1*$2*$3)-$4 )}'`
      set smpE = `echo "$smpS $durSMP $pmSMP" |gawk '{printf("%d",($1+$2)+(2.*$3) )}'`
      set passtyp = ".normal2"; 
      ls *"$NVTID"*.vlp.ascii > tmp.lst.$$
      if ( "$passtyp" == ".normal2" ) then
        foreach if (` cat tmp.lst.$$ `)
          set of = `echo $if |sed 's@.vlp.ascii@.vlp'"$passtyp"'.ascii@g'` 
          sed -n ''"$smpS"','"$smpE"'p' $if |sort -k 1,1n > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set MIN = `sed -n '1,1p' tmp.srtd.$$`
          gawk 'BEGIN{\
            min=sprintf("%f","'"$MIN"'"+0. );\
          }{\
            printf("%f\n",$1-min+0.);\
          }' tmp.srtd.$$ > tmp.srtd-shftd.$$
          set N75 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.75)+0.5) )}'`
          set V75 = `sed -n ''"$N75"','"$N75"'p' tmp.srtd-shftd.$$`
          gawk 'BEGIN{\
            shft=sprintf("%f","'"$MIN"'"+0. );\
            norm=sprintf("%f","'"$V75"'"+0. );\
            if(norm+0. == 0.+0.){norm=1.0+0.};\
          }{\
            val=sprintf("%.14lf\n",($1-shft) );\
            if(val+0. < 0.+0.){val=sprintf(".14lf\n",0.+0. )};\
            printf("%.14lf\n",(val/norm)+0. );\
          }' $if > $of
        end
      endif
      paste *"$NVTID"*.vlp"$passtyp".ascii > dat.vlp-combo"$passtyp"
      wc dat.vlp-combo"$passtyp"
     "$utl"/mbells
      sed -n '1,1p' dat.vlp-combo"$passtyp" |gawk '{print NF}'



#D    = Convert wfs to ascii
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
      ls *"$NVTID".trmd > tmp.FNs2.$$
      foreach fn (` cat tmp.FNs2.$$ |sed -n '1,$p' `)
        set of = `echo $fn |sed 's/\.trmd/\.ascii/'`
        qmerge -T -d 1024 $fn |egrep -v 'seq\=' > $of
        echo $of
      end
#mkDAT stop
endif


echo "A1111"


#DS===:: OPTIONAL ::
#DS===:: OPTIONAL ::
      if ( "$mkPLOTs" == "Y" ) then


#D      = TRADITIONAL STACK of wfs
#D      = Combine wf ts's (already done above for vlps)
#D
#D        + Combine wfs
#D    (OTPT: dat.wf-combo{passtyp} )
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
      set passtyp = ""; echo "## INITIAL pass ##"
      if ( "$passtyp" == "" ) then
         echo "## INITIAL PASS ##"
         paste *"$NVTID".ascii > dat.wf-combo"$passtyp"
      endif
      wc dat.wf-combo"$passtyp"
#    "$utl"/mbells

#D       + PLOT TRADITIONAL STACK of wfs
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set SPSwf = 20; 
        set DECIMATE = 5
        set SPSplt = `echo $SPSwf $DECIMATE |gawk '{printf("%d",int(($1/$2)+0.5) )}'`\
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set sT = `caldate -- $nvtSTRT -5M`
        set eT = `caldate -- $nvtEND  +5M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set passtyp = ""
        set if = dat.wf-combo"$passtyp"
        gawk 'BEGIN{sum=0.+0.}{\
          for(i=1+0;i<=NF+0;i++){\
            sum=sprintf("%.10f",sum+$i+0. );\
          }\
          printf("%f\n",sum/NF+0. );\
          sum=0.+0.;\
        }' $if > tmp.$$
        set DC = `$utl/mav tmp.$$ |gawk '{printf("%lf\n",$6+0. )}'`
        set OCT7 = `$utl/mmed7 tmp.$$ |gawk '{printf("%lf\n",$14+0. )}'`
        gawk '{\
          decim=sprintf("%d","'"$DECIMATE"'"+0. );\
        }{\
          if( (NR % decim) == 1+0 ){\
            printf("%lf\n",(($1-"'"$DC"'")+0.)/("'"$OCT7"'"+0.) );\
          }\
        }' tmp.$$  > dat.TRADITIONAL-STACK_wfs
        $utl/mGplt.TRADITIONAL-STACK_wfs dat.TRADITIONAL-STACK_wfs  $NVTID $pLEN $SPSplt
        /bin/rm tmp.$$
        mv myp2 myp.TRADITIONAL-STACK_wfs.ps



#D      = TRADITIONAL STACK of vlps
#D       + PLOT TRADITIONAL STACK of vlp -- REGULAR or NORMALIZED
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set sT = `caldate -- $nvtSTRT -5M`
        set eT = `caldate -- $nvtEND  +5M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        foreach passtyp ( ""  ".normal2" )
          set if = dat.vlp-combo"$passtyp"
          gawk 'BEGIN{sum=0.+0.}{\
            for(i=1+0;i<=NF+0;i++){\
              sum=sprintf("%.10f",sum+$i+0. );\
            }\
            printf("%f\n",sum/NF+0. );\
            sum=0.+0.;\
          }' $if > tmp.$$
          sort -k 1,1n tmp.$$ > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
        echo "RNG: V98-V2"
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          gawk 'BEGIN{\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
              printf("%lf\n",(1.0*($1-shft)/rng)+0. );\
          }' tmp.$$ > dat.TRADITIONAL-STACK_vlp.normal"$passtyp"
          $utl/mGplt.TRADITIONAL-STACK_vlps dat.TRADITIONAL-STACK_vlp.normal"$passtyp"  $NVTID $pLEN
          /bin/rm tmp.$$
          mv myp2 myp.TRADITIONAL-STACK_vlp-combo"$passtyp".ps
        end



#D      = SUITE of ALL ORIGINAL wfs:  REGULAR and NORMALIZED
        cd $datDIR
        set DECIMATE = 5
        set DECIMATE = 10
        set SPSwf = 20; 
        set SPSwfPLT = `echo $SPSwf $DECIMATE |gawk '{printf("%d",int(($1/$2)+0.5) )}'`
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set sT = `caldate -- $nvtSTRT -5M`
        set eT = `caldate -- $nvtEND  +5M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
   echo "# REGULAR"
        set Ntrc = `ls *.D.*"$NVTID".ascii |wc |gawk '{print $1}'` 
        /bin/rm tmp.$$;  touch tmp.$$
        foreach if (` ls *.D.*"$NVTID".ascii `)
          set MEAN = `"$utl"/mav $if |gawk '{printf("%f\n",$6+0. )}'`
          gawk 'BEGIN{\
            shft=sprintf("%f","'"$MEAN"'"+0. );\
          }{\
            printf("%lf\n",($1-shft)+0. ) ;\
          }' $if >> tmp.$$
        end
        sort -k 1,1n tmp.$$ > tmp.srtd-all.$$
        set NSMPall = `wc tmp.srtd-all.$$ |gawk '{printf("%d", $1 )}'`
        set N2all = `echo $NSMPall |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
        set N98all = `echo $NSMPall |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
        set V2all = `sed -n ''"$N2all"','"$N2all"'p' tmp.srtd-all.$$`
        set V98all = `sed -n ''"$N98all"','"$N98all"'p' tmp.srtd-all.$$`
        set iTRC = `echo 0 |gawk '{printf("%d",$1+0. )}'`

        /bin/rm pltdat.SUITE.tmp;  touch pltdat.SUITE.tmp
        foreach if (` ls *.D.*"$NVTID".ascii |sed -n '1,$p' `)
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set MEAN = `"$utl"/mav $if |gawk '{printf("%f\n",$6+0. )}'`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set RNGall = `echo $V98all $V2all |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1+1. )}'`
          gawk 'BEGIN{\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            v2all=sprintf("%f","'"$V2all"'"+0. );\
            v98all=sprintf("%f","'"$V98all"'"+0. );\
            shft=sprintf("%f","'"$MEAN"'"+0. );\
            v98=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            rngall=sprintf("%f","'"$RNGall"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
            if(rngall+0. == 0.+0.){rngall=1.0+0.};\
          }{\
            if( (NR % decim) == 1+0 ){\
              printf("%lf\n",(0.7*($1-shft)/rngall)+(itrc+0.) ) ;\
            }\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE.tmp
        end

   echo "# NORMALIZED"
        /bin/rm pltdat.SUITE.norm;  touch pltdat.SUITE.norm
        set iTRC = `echo 0 |gawk '{printf("%d",$1+0. )}'`
        foreach if (` ls *.D.*"$NVTID".ascii |sed -n '1,$p' `)
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set MEAN = `"$utl"/mav $if |gawk '{printf("%f\n",$6+0. )}'`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1+1. )}'`
          gawk 'BEGIN{\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$MEAN"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
            if( (NR % decim) == 1+0 ){\
              printf("%lf\n",(0.7*($1-shft)/rng)+(itrc+0.) ) ;\
            }\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE.norm
        end
        "$utl"/mGplt.ptil-SUITE-ALL.wfs  $Ntrc  pltdat.SUITE.tmp  pltdat.SUITE.norm  $pLEN $SPSwfPLT
        mv myp2 myp.ptil-SUITE-ALL.wfs.ps


#D      = SUITE of ALL ORIGINAL vlps:  REGULAR and NORMALIZED
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set sT = `caldate -- $nvtSTRT -5M`
        set eT = `caldate -- $nvtEND  +5M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set typa = "";
        set typb = ".normal2";
   echo "# REGULAR"
        set Ntrc = `ls *.D.*"$NVTID"*.vlp"$typa".ascii |wc |gawk '{print $1}'` 
        /bin/rm tmp.$$;  touch tmp.$$
        foreach if (` ls *.D.*"$NVTID"*.vlp"$typa".ascii `)
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set MIN = `sed -n '1,1p' tmp.srtd.$$`
          gawk 'BEGIN{\
            shft=sprintf("%f","'"$MIN"'"+0. );\
          }{\
            printf("%lf\n",($1-shft)+0. ) ;\
          }' $if >> tmp.$$
        end
        sort -k 1,1n tmp.$$ > tmp.srtd-all.$$
        set NSMPall = `wc tmp.srtd-all.$$ |gawk '{printf("%d", $1 )}'`
        set N98all = `echo $NSMPall |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
        set V98all = `sed -n ''"$N98all"','"$N98all"'p' tmp.srtd-all.$$`
        set iTRC = `echo 0 |gawk '{printf("%d",$1+0. )}'`
        /bin/rm pltdat.SUITE.tmp;  touch pltdat.SUITE.tmp
        foreach if (` ls *.D.*"$NVTID"*.vlp"$typa".ascii |sed -n '1,$p' `)
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1+1. )}'`
          gawk 'BEGIN{\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            v98all=sprintf("%f","'"$V98all"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
          }{\
            printf("%lf\n",(5.0*($1-shft)/v98all)+(itrc+0.) ) ;\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE.tmp
        end

   echo "# NORMALIZED"
        /bin/rm pltdat.SUITE.norm;  touch pltdat.SUITE.norm
        set iTRC = `echo 0 |gawk '{printf("%d",$1+0. )}'`
        foreach if (` ls *.D.*"$NVTID"*.vlp"$typb".ascii |sed -n '1,$p' `)
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1+1. )}'`
          gawk 'BEGIN{\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
            printf("%lf\n",(1.5*($1-shft)/rng)+(itrc+0.) ) ;\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE.norm
        end
        "$utl"/mGplt.ptil-SUITE-ALL  $Ntrc  pltdat.SUITE.tmp  pltdat.SUITE.norm  $pLEN
        mv myp2 myp.ptil-SUITE-ALL.vlps.ps


      endif
      if ( "$vuPLOTs" == "Y" ) then
        cd $vuPLTdir
        gv myp.TRADITIONAL-STACK_wfs.ps
        foreach passtyp ( ""  ".normal2" )
          gv myp.TRADITIONAL-STACK_vlp-combo"$passtyp".ps
        end
        gv myp.ptil-SUITE-ALL.wfs.ps
        gv myp.ptil-SUITE-ALL.vlps.ps
      endif
#DE===:: OPTIONAL ::
#DE===:: OPTIONAL ::


echo "A2222"


if ( "$mkDAT" == "Y" ) then
#D        + Ptil-Sort by rows ( Slowish but not too bad )
#D          . PYTHON code
#D    (OTPT: dat.vlp-combo-srtd{passtyp} )
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
      set passtyp = ".normal2"
      set if = dat.vlp-combo"$passtyp"
      $spy2; echo "source shared libraries for PYTHON 2"
      $utl/mrow-sort.py $if |egrep -v 'None' > dat.vlp-combo-srtd"$passtyp"


#D      = d) Make DATA SUITE of ptil stacked ts's (e.g., 10% 20% 30% etc.) -- NORMALIZED
#D      . Keep only a max of +/- 'nwfmax' other ts's w/i 15 %
#D      . Ntrc is the number of starting traces
#D      . N2use is how many percentiles will be processed.
#D      . Program selects _N2use_ evenly spaced percentile traces to process.
#D      . There must be at least 7 percentile traces processed (1 every 15%)
#D      . When there are more than 7 traces available, spacing will remain
#D          at every 15% unless more than _nwfmax_ traces per 15% are available.
#D          When that happens, increments smaller than every 15% will be used.
#D    (OTPT:  dat.vlp-stack-srtd_{ptil}{$passtyp}
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
      set passtyp = ".normal2";
      set if = dat.vlp-combo-srtd"$passtyp"
      set Ntrc = `sed -n '1,1p' $if |gawk '{printf("%d\n", NF )}'`
      set pRNG = "15."; echo "+/- 15% Neighbors--USED; Will work as long as at least 7 ts"
      set nwfmax = 9999; echo "PLOT all ptil-sorted ts(s)"
      set nwfmax = 4; echo "STANDARD"
      set nwfmin = 1
      echo ""|\
      gawk 'BEGIN{\
          ntrc=sprintf("%d","'"$Ntrc"'"+0 );\
          prng=sprintf("%f","'"$pRNG"'"+0 );\
          nwfmin=sprintf("%d","'"$nwfmin"'"+0 );\
          nwfmax=sprintf("%d","'"$nwfmax"'"+0 );\
          nwf_prcnt=sprintf("%f",ntrc/100.+0. );\
          nwf=sprintf("%d",(nwf_prcnt*prng) );\
          evry=sprintf("%d",1+0 );\
      }{\
        while(nwf/evry+0 > nwfmax+0 ){\
          evry=evry+1;\
        }\
        if(nwf/evry+0 < nwfmin+0){\
          print "ABORT ABORT  Too Few Waveforms";\
          exit;\
        }\
        print "EVERY: ",evry;\
      }'  > tmp.incTRC.$$
      set incTRC = `cat tmp.incTRC.$$ |gawk '{print $2}'`
      if ( "$incTRC" == "ABORT" ) then 
        echo;\
        echo "ABORTED:  \!\!\! TO FEW WFS \!\!\!" ;\
        echo;\
        "$utl"/mbells
      endif
      set N2use = `echo $Ntrc $incTRC |gawk '{printf("%f",int(($1/$2)+0.5) )}'`
      echo "" |\
        gawk 'BEGIN{\
          ntrc=sprintf("%d","'"$Ntrc"'"+0.);\
          n2use=sprintf("%d","'"$N2use"'"+0.);\
        }{\
          for(i=1;i<=(n2use+0);i=i+1){\
            printf("%.3f\n",(i+0)/n2use );\
          }\
        }' > tmp.ptils.$$

      /bin/rm dat.vlp-stack-srtd_?.???"$passtyp"
      foreach ptil (` cat tmp.ptils.$$ `) 
        set of = dat.vlp-stack-srtd_"$ptil""$passtyp"
        gawk 'BEGIN{\
          ptil=sprintf("%f","'"$ptil"'"+0. );\
        }{\
         Nsmps=NF+0;\
         Nptil=sprintf("%d",int((Nsmps*ptil)+0.5) );\
         Vptil=sprintf("%f",$Nptil+0. );\
         print Vptil;\
        }' $if |tee $of
      end

    

#D      = e) Truncate SUITE of ptil stack ts's from d)
#D        + (USE ptilTRUNC == 0.993; see: src_RM.proc)
#D       . TRUNCATION STABALIZES XC COMPUTATION
#D    (OTPT:  dat.vlp-stack-srtd_{ptil}{passtyp}_TRUNC  )
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
      set passtyp = ".normal2"
      set ptilTRUNC = 0.993; echo "USE THIS corresponds to 10 min. of truncation for 24 hr data"
                             echo "Corresponds to 10  sec. of truncation for 24 mins. data"
                             echo "Corresponds to 7.1 sec. of truncation for 17 mins. data"
      ls dat.vlp-stack-srtd_?.???"$passtyp" |\
        sed -n '1,$p' > tmp.list.$$
      /bin/rm dat.vlp-stack-srtd_?.???.normal2_TRUNC
      foreach chnFN (` cat tmp.list.$$ `)
        echo "$chnFN"
        set Nsmp = `wc $chnFN |gawk '{printf("%d",$1)}'`
        sort -k 1,1n $chnFN |\
        cat -n  |\
        gawk 'BEGIN{Nsmp=sprintf("%d","'"$Nsmp"'"+0)}{\
          printf("%d %f %f\n",$1+0,($1/Nsmp)+0.,$2+0. );\
        }' > tmp.srtd.$$
      echo "## Now get the ptilTRUNC value and  Truncate ts ##"
        set pTRUNCnum = `echo $Nsmp $ptilTRUNC |gawk '{printf("%d\n",$1*$2 )}'`
        set pTRUNCval = `sed -n ''"$pTRUNCnum"'p' tmp.srtd.$$ |gawk '{printf("%f",$3+0. )}'`
        gawk 'BEGIN{pTval=sprintf("%f","'"$pTRUNCval"'"+0.)}{\
          val=sprintf("%f",$1+0.);\
          if(val+0. <= pTval+0.){\
            printf("%f\n",val+0.);\
          }else{\
            printf("%f\n",pTval+0.);\
          }\
        }' $chnFN > "$chnFN"_TRUNC
      end
#mkDAT stop
endif


echo "A3333"


#DS===:: OPTIONAL ::
#DS===:: OPTIONAL ::
      if ( "$mkPLOTs" == "Y" ) then


#D       + PLOT SUITE of ptil-STACK and/or TRUNCATED time-series
#D         . Shifted to V2
#D         . Divided by RNG (i.e., V98-V2)
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set sT = `caldate -- $nvtSTRT -5M`
        set eT = `caldate -- $nvtEND  +5M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set passtyp = ""; echo "## INITIAL pass ##"
        set passtyp = ".normal"; echo "## INITIAL pass ##"
        set passtyp = ".normal2"; echo "## INITIAL pass ##"
        set Ntrc = `ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |wc |gawk '{print $1}'`
        set EVRY = "05"
        set EVRY = "03"
        set EVRY = "02"
        set EVRY = "01"
        ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |\
          gawk 'BEGIN{\
            ntrc=sprintf("%d","'"$Ntrc"'"+0.);\
            evry=sprintf("%d","'"$EVRY"'"+0.);\
            i=0+0;\
          }{\
            i=i+1;\
            lin[i]=$0;\
          }END{\
            for(j=(evry+0);j<=(ntrc+0);j=j+evry){\
              split(lin[j],aa,"_");\
              print substr(aa[2],1,5);\
            }\
          }' > tmp.ptils.$$

        /bin/rm pltdat.SUITE.tmp;  touch pltdat.SUITE.tmp
        /bin/rm pltdat.SUITE.norm;  touch pltdat.SUITE.norm
        foreach ptil (` cat tmp.ptils.$$ `) 
          set if = dat.vlp-stack-srtd_"$ptil""$passtyp"_TRUNC
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
#      echo "RNG: V98-V2"
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
#echo $ptil $Nsmp $N2 $N98 $V2 $V98 $RNG
          gawk 'BEGIN{\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
            printf("%lf\n",(4.0*($1-shft)/1.0)+("'"$ptil"'"*100.)+0. ) >> "pltdat.SUITE.tmp" ;\
            printf("%lf\n",(4.0*($1-shft)/rng)+("'"$ptil"'"*100.)+0. ) >> "pltdat.SUITE.norm" ;\
          }END{\
            print "sss" >> "pltdat.SUITE.tmp" ;\
            print "sss" >> "pltdat.SUITE.norm" ;\
          }' $if 
        end
        "$utl"/mGplt.ptil-SUITE  pltdat.SUITE.tmp  pltdat.SUITE.norm  $pLEN
        mv myp2 myp.ptil-SUITE"$passtyp".evry-"$EVRY".ps



#D      = TRANSFORMATION FIGURE
#D        . Left panel  will be SUITE of normalized un-ordered vlps
#D        . Right panel will be corresponding SUITE after percentile transformation (absolute scaled).
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set sT = `caldate -- $nvtSTRT -5M`
        set eT = `caldate -- $nvtEND  +5M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`

     echo "Left Panel"
        set typb = ".normal2";
        set ofl = pltdat.TRANSFORM.left
        /bin/rm $ofl; touch $ofl
        set Ntrc = `  ls *.D.*"$NVTID"*.vlp"$typb".ascii |wc |gawk '{print $1}'` 
        set iTRC = `echo 0 |gawk '{printf("%d",$1+0. )}'`
        foreach if (` ls *.D.*"$NVTID"*.vlp"$typb".ascii |sed -n '1,$p' `)
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1+1. )}'`
          gawk 'BEGIN{\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
            printf("%lf\n",(1.5*($1-shft)/rng)+(itrc+0.) ) ;\
          }END{\
            print "sss";\
          }' $if >> $ofl
        end

     echo "Right Panel"
       echo "Extract ptil-sortd time ts_s"
#D      = d) Make DATA SUITE of ptil stacked ts's (e.g., 10% 20% 30% etc.) 
#D      . Keep All ptil ts's
#D      . Ntrc is the number of starting traces
#D      . N2use is how many percentiles will be processed.
#D      . Program selects _N2use_ evenly spaced percentile traces to process.
#D      . There must be at least 7 percentile traces processed (1 every 15%)
#D      . When there are more than 7 traces available, spacing will remain
#D          at every 15% unless more than _nwfmax_ traces per 15% are available.
#D          When that happens, increments smaller than every 15% will be used.
#D      . nwfmax = 9999 plots ALL ptil-sorted ts_s
#D    (OTPT:  tmp.ptil-transformation-srtd_{ptil} )
      set passtyp = ".normal2";
      set if = dat.vlp-combo-srtd"$passtyp"
      set Ntrc = `sed -n '1,1p' $if |gawk '{printf("%d\n", NF )}'`
      set pRNG = "15."; echo "+/- 15% Neighbors--USED; Will work as long as at least 7 ts"
      set nwfmax = 4; echo "STANDARD"
      set nwfmax = 9999; echo "PLOT all ptil-sorted ts(s)"
      set nwfmin = 1
      echo ""|\
      gawk 'BEGIN{\
          ntrc=sprintf("%d","'"$Ntrc"'"+0 );\
          prng=sprintf("%f","'"$pRNG"'"+0 );\
          nwfmin=sprintf("%d","'"$nwfmin"'"+0 );\
          nwfmax=sprintf("%d","'"$nwfmax"'"+0 );\
          nwf_prcnt=sprintf("%f",ntrc/100.+0. );\
          nwf=sprintf("%d",(nwf_prcnt*prng) );\
          evry=sprintf("%d",1+0 );\
      }{\
        while(nwf/evry+0 > nwfmax+0 ){\
          evry=evry+1;\
        }\
        if(nwf/evry+0 < nwfmin+0){\
          print "ABORT ABORT  Too Few Waveforms";\
          exit;\
        }\
        print "EVERY: ",evry;\
      }'  > tmp.incTRC.$$
      set incTRC = `cat tmp.incTRC.$$ |gawk '{print $2}'`
      if ( "$incTRC" == "ABORT" ) then 
        echo;\
        echo "ABORTED:  \!\!\! TO FEW WFS \!\!\!" ;\
        echo;\
        "$utl"/mbells
      endif
      set N2use = `echo $Ntrc $incTRC |gawk '{printf("%f",int(($1/$2)+0.5) )}'`
      echo "" |\
        gawk 'BEGIN{\
          ntrc=sprintf("%d","'"$Ntrc"'"+0.);\
          n2use=sprintf("%d","'"$N2use"'"+0.);\
        }{\
          for(i=1;i<=(n2use+0);i=i+1){\
            printf("%.3f\n",(i+0)/n2use );\
          }\
        }' > tmp.ptils.$$
      /bin/rm tmp.ptil-transformation-srtd_?.???
      foreach ptil (` cat tmp.ptils.$$ `) 
        set of = tmp.ptil-transformation-srtd_"$ptil"
        gawk 'BEGIN{\
          ptil=sprintf("%f","'"$ptil"'"+0. );\
        }{\
         Nsmps=NF+0;\
         Nptil=sprintf("%d",int((Nsmps*ptil)+0.5) );\
         Vptil=sprintf("%f",$Nptil+0. );\
         print Vptil;\
        }' $if > $of
      end

#D      = e) Truncate SUITE of ptil stack ts's from d)
#D        + (USE ptilTRUNC == 0.993; see: src_RM.proc)
#D       . TRUNCATION STABALIZES XC COMPUTATION
#D    (OTPT:  dat.vlp-stack-srtd_{ptil}{passtyp}_TRUNC  )
      set ptilTRUNC = 0.993; echo "USE 0.993, corresponds to 10 min. of truncation for 24 hr data"
                             echo "Corresponds to 10  sec. of truncation for 24 mins. data"
                             echo "Corresponds to 7.1 sec. of truncation for 17 mins. data"
      ls tmp.ptil-transformation-srtd_?.??? |\
        sed -n '1,$p' > tmp.list.$$
      /bin/rm tmp.ptil-transformation-srtd_?.???_TRUNC
      foreach chnFN (` cat tmp.list.$$ `)
#       echo "$chnFN"
        set Nsmp = `wc $chnFN |gawk '{printf("%d",$1)}'`
        sort -k 1,1n $chnFN |\
        cat -n  |\
        gawk 'BEGIN{Nsmp=sprintf("%d","'"$Nsmp"'"+0)}{\
          printf("%d %f %f\n",$1+0,($1/Nsmp)+0.,$2+0. );\
        }' > tmp.srtd.$$
#     echo "## Now get the ptilTRUNC value and  Truncate ts ##"
        set pTRUNCnum = `echo $Nsmp $ptilTRUNC |gawk '{printf("%d\n",$1*$2 )}'`
        set pTRUNCval = `sed -n ''"$pTRUNCnum"'p' tmp.srtd.$$ |gawk '{printf("%f",$3+0. )}'`
        gawk 'BEGIN{pTval=sprintf("%f","'"$pTRUNCval"'"+0.)}{\
          val=sprintf("%f",$1+0.);\
          if(val+0. <= pTval+0.){\
            printf("%f\n",val+0.);\
          }else{\
            printf("%f\n",pTval+0.);\
          }\
        }' $chnFN > "$chnFN"_TRUNC
      end
        set passtyp = ".normal2";
        set Ntrc = `ls tmp.ptil-transformation-srtd_?.???_TRUNC |wc |gawk '{print $1}'`
        set EVRY = "01"
        ls tmp.ptil-transformation-srtd_?.???_TRUNC |\
          gawk 'BEGIN{\
            ntrc=sprintf("%d","'"$Ntrc"'"+0.);\
            evry=sprintf("%d","'"$EVRY"'"+0.);\
            i=0+0;\
          }{\
            i=i+1;\
            lin[i]=$0;\
          }END{\
            for(j=(evry+0);j<=(ntrc+0);j=j+evry){\
              split(lin[j],aa,"_");\
              print substr(aa[2],1,5);\
            }\
          }' > tmp.ptils.$$

        set ofr = pltdat.TRANSFORM.right
        /bin/rm $ofr; touch $ofr
        set iTRC = `echo 0 |gawk '{printf("%d",$1+0. )}'`
        foreach ptil (` cat tmp.ptils.$$ `) 
          set if = tmp.ptil-transformation-srtd_"$ptil"_TRUNC 
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
#     echo "RNG: V98-V2"
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1+1. )}'`
#echo $ptil $Nsmp $N2 $N98 $V2 $V98 $RNG
          gawk 'BEGIN{\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
          }{\
            printf("%lf\n",(4.0*($1-shft)/1.0)+(itrc+0.) ) >> "'"$ofr"'" ;\
          }END{\
            print "sss" >> "'"$ofr"'" ;\
          }' $if 
        end
        "$utl"/mGplt.vlp-TRANSFORMATION  $Ntrc  $ofl $ofr  $pLEN
        mv myp2 myp.vlp-TRANSFORMATION.ps


      endif
      if ( "$vuPLOTs" == "Y" ) then
        cd $vuPLTdir
        set passtyp = ".normal2"
        set EVRY = "01"
        gv myp.vlp-TRANSFORMATION.ps
        gv myp.ptil-SUITE"$passtyp".evry-"$EVRY".ps
      endif
#DE===:: OPTIONAL ::
#DE===:: OPTIONAL ::


echo "A4444"


if ( "$mkDAT" == "Y" ) then
#D      = f) Find suitable/best ptil using max-XC, LAGs, and KURTOSIS 
#D           [Decided against using RMSD (i.e., RMS deviation) or
#D            NRMSD (normalized RMSD (see wiki) since this will
#D            require more pair-wise processing which is 1) time consuming
#D            for testing, 2) will just add more to processing time,
#D            and 3) at best will probably yield an incremental improvement
#D            to the results].
#D        + Compile Kurtosis info [1/2*(V75-V25)]/(p90-p10)
#D          . The minimum vlp values are substracted so simple S/N
#D              is no longer a suitable measure of signal strength
#D          . Instead I'll use Kurtosis DURING THE DETECTION PERIOD
#D              as a measure of signal strength
#D          . larger Kurtosis means less dispersion 
#D              (i.e., many samples with about the same  amplitudes)
#D          . Smaller Kurtosis implies more high and low amplitude constrasts
#D            (i.e. more signal!)
#D          . Kurtosis equation is from Schaum p. 91: 
#D              Kurtosis == [1/2*(V75-V25)]/(p90-p10)
#D      ## ptil KURTOSIS
#D         = USE ONLY DETECTION PERIOD for normalization !!!
#D      (OTPT:  l.KURTOSIS_pSTCKs{passtyp} )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set SPSvlp = 10
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set dM = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$1)}'`
        set dS = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$2)}'`
        set dF = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$3)}'`
  set durSMP = `echo "$dM $dS $dF $SPSvlp" |gawk '{printf("%d",($1*60*$4)+($2*$4)+(($3/10000)*$4) )}'`
        set pmSMP = 150; echo "(15 sec at 10 sps)"
        set smpS = `echo "5. 60. $SPSvlp $pmSMP" |gawk '{printf("%d",($1*$2*$3)-$4 )}'`
        set smpE = `echo "$smpS $durSMP $pmSMP" |gawk '{printf("%d",($1+$2)+(2.*$3) )}'`
        set passtyp = ".normal2"; echo "## INITIAL pass ##"
        set Ntrc = `ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |wc |gawk '{print $1}'`
        set EVRY = "01"
        ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |\
          gawk 'BEGIN{\
            ntrc=sprintf("%d","'"$Ntrc"'"+0.);\
            evry=sprintf("%d","'"$EVRY"'"+0.);\
            i=0+0;\
          }{\
            i=i+1;\
            lin[i]=$0;\
          }END{\
            for(j=(evry+0);j<=(ntrc+0);j=j+evry){\
              split(lin[j],aa,"_");\
              print substr(aa[2],1,5);\
            }\
          }' > tmp.ptils.$$
        echo "## KURTOSIS == (1/2*IQR)/(P90-P10); Schaum p. 91 ##"
        echo "00A   pStackFilename                     IQR      P90     P10     KURTOSIS"  \
          |tee l.KURTOSIS_pSTCKs"$passtyp"

        foreach ptil (` cat tmp.ptils.$$ `) 
          set if = dat.vlp-stack-srtd_"$ptil""$passtyp"_TRUNC
          sed -n ''"$smpS"','"$smpE"'p' $if |sort -k 1,1n > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N10 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.10)+0.5) )}'`
          set N25 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.25)+0.5) )}'`
          set N75 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.75)+0.5) )}'`
          set N90 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.90)+0.5) )}'`
          set P10 = `sed -n ''"$N10"','"$N10"'p' tmp.srtd.$$`
          set P25 = `sed -n ''"$N25"','"$N25"'p' tmp.srtd.$$`
          set P75 = `sed -n ''"$N75"','"$N75"'p' tmp.srtd.$$`
          set P90 = `sed -n ''"$N90"','"$N90"'p' tmp.srtd.$$`
          set IQR = `echo $P75 $P25 |gawk '{printf("%f",$1-$2+0. )}'`
          echo $IQR $P90 $P10 |\
            gawk '{\
              p90p10=sprintf("%f",($2-$3)+0. );\
              if(p90p10+0. == 0.+0.){ p90p10=1.0+0.}\
              hlfIQR=sprintf("%f",($1/2.)+0. );\
              if(hlfIQR+0. == 0.+0.){hlfIQR=1.0+0.}\
              krt=sprintf("%f",(hlfIQR)/(p90p10)+0.);\
              printf("%f",krt+0. );\
            }' > tmp.$$
          set KURT = `cat tmp.$$`
          /bin/rm tmp.$$
          echo $if $IQR $P90 $P10 $KURT |tee -a l.KURTOSIS_pSTCKs"$passtyp" 
        end



#D      ## ptil XCs and LAGs
#D         = USE ONLY DETECTION PERIOD for XC !!!
#D         = ONLY COMPUTE ptils w/i 15% to save time
#D         = Using lag info to improve final discrimination (slower; may be excessive)
#D      (OTPT:  l.ref-test.raw{passtyp}  )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set passtyp = ".normal2"; echo "## INITIAL pass ##"
        set SPSvlp = 10
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set dM = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$1)}'`
        set dS = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$2)}'`
        set dF = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$3)}'`
  set durSMP = `echo "$dM $dS $dF $SPSvlp" |gawk '{printf("%d",($1*60*$4)+($2*$4)+(($3/10000)*$4) )}'`
        set pmSMP = 150; echo "(15 sec at 10 sps)"
        set smpS = `echo "5. 60. $SPSvlp $pmSMP" |gawk '{printf("%d",($1*$2*$3)-$4 )}'`
        set strt = $smpS; 
        set swlen = `echo "$durSMP $pmSMP" |gawk '{printf("%d",$1+(2.*$2) )}'`
        set Ntrc = `ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |wc |gawk '{print $1}'`
        set EVRY = 1
        set pRNG = "0.15"; echo "+/- 15% Neighbors--USED; Will work as long as at least 7 ts"
        ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |\
          gawk 'BEGIN{\
            ntrc=sprintf("%d","'"$Ntrc"'"+0.);\
            evry=sprintf("%d","'"$EVRY"'"+0.);\
            i=0+0;\
          }{\
            i=i+1;\
            lin[i]=$0;\
          }END{\
            for(j=(evry+0);j<=(ntrc+0);j=j+evry){\
              split(lin[j],aa,"_");\
              print "_"substr(aa[2],1,5);\
            }\
          }' > tmp.ptils.$$

        ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |sed -n '1,$p' |\
          egrep -f tmp.ptils.$$ |\
        gawk 'BEGIN{\
          i=0+0;\
          prng=sprintf("%.2f","'"$pRNG"'"+0. );\
        }{\
          i++;\
          fn[i]=$0;\
        }END{\
          for(j=1+0;j<=i-1;j++){\
            split(fn[j],a,"_");\
            ptil1=substr(a[2],1,5);\
            for(k=j+1;k<=i+0;k++){\
              split(fn[k],a2,"_");\
              ptil2=substr(a2[2],1,5);\
              if(ptil2+0. <= (ptil1+prng+0.) ){\
                print fn[j]"@@@"fn[k];\
              }\
            }\
          }\
        }' > tmp.pars.$$

        set stp = 1
        set mnlag = -0; set mxlag = 0
        set mnlag = -10; set mxlag = 10
        set of = l.ref-test.raw"$passtyp"
        /bin/rm $of; touch $of
        foreach par (` cat tmp.pars.$$ |sed -n '1,$p' `)
          set ts1 = `echo $par |sed 's/\@\@\@/ /g' |gawk '{print $1}'`
          set ts2 = `echo $par |sed 's/\@\@\@/ /g' |gawk '{print $2}'`
          $utl/mxc.v9 $ts1 $ts2 $strt $swlen $stp $mnlag $mxlag |\
            sort -k 5,5n |sed -n '$,$p' |tee -a $of
        end
        wc l.ref-test.raw"$passtyp"



#D        + ptil XC and LAG SUMMARY 
#D          . Looking for maximum XC with neighboring percentil stack 
#D            (i.e., w/i +/- 15%)
#D          . For Example for 70% ptil and 15% increments I will average
#D            XCs for all percentiles between 55% and 85% with the 70%ile level vlp.
#D        (OTPT: l.ref-test.summ{passtyp}
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set passtyp = ".normal2"; echo "## INITIAL pass ##"
        set if = l.ref-test.raw"$passtyp"
        set of = l.ref-test.summ"$passtyp"
        set pRNG = "0.10"; echo "+/- 10% Neighbors"
        set pRNG = "0.05"; echo "+/-  5% Neighbors"
        set pRNG = "0.20"; echo "+/- 20% Neighbors"
        set pRNG = "0.25"; echo "+/- 20% Neighbors"
        set pRNG = "0.15"; echo "+/- 15% Neighbors--USED"
        set Ntrc = `ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |wc |gawk '{print $1}'`
        set EVRY = "02"
        set EVRY = "05"
        set EVRY = "03"
        set EVRY = "01"
        ls dat.vlp-stack-srtd_?.???"$passtyp"_TRUNC |\
          gawk 'BEGIN{\
            ntrc=sprintf("%d","'"$Ntrc"'"+0.);\
            evry=sprintf("%d","'"$EVRY"'"+0.);\
            i=0+0;\
          }{\
            i=i+1;\
            lin[i]=$0;\
          }END{\
            for(j=(evry+0);j<=(ntrc+0);j=j+evry){\
              split(lin[j],aa,"_");\
              print substr(aa[2],1,5);\
            }\
          }' > tmp.ptils.$$

        /bin/rm tmp.otpt.$$; touch tmp.otpt.$$
        foreach ptil (` cat tmp.ptils.$$ `) 
          set ptilMX = `echo $ptil |gawk '{printf("%.2f",$1+"'"$pRNG"'"+0. )}'`
          set ptilMN = `echo $ptil |gawk '{printf("%.2f",$1-"'"$pRNG"'"+0. )}'`
          egrep "\_$ptil\_|\_$ptil\." $if |\
            gawk 'BEGIN{\
              pmn=sprintf("%.2f","'"$ptilMN"'"+0. );\
              pmx=sprintf("%.2f","'"$ptilMX"'"+0. );\
            }{\
              split($1,aa,"_");\
              split($2,bb,"_");\
              pf1=sprintf("%.2f",substr(aa[2],1,5)+0. );\
              pf2=sprintf("%.2f",substr(bb[2],1,5)+0. );\
              if(pmn+0. <= pf1+0. && pf1+0. <= pmx+0.){\
                if(pmn+0. <= pf2+0. && pf2+0. <= pmx+0.){\
                  print $0;\
                }\
              }\
            }' > tmp.$$
          set AvOfNeighbors = `gawk '{print $5}' tmp.$$ |"$utl"/mav |gawk '{print $6}'`
          set avABSlag = `gawk '{print sqrt($4^2)}' tmp.$$ |"$utl"/mav |gawk '{print $6}'`
          set ptilFN = \
  `gawk '{print $1;print $2}' tmp.$$ |sort |uniq -c |sort -k 1,1n|sed -n '$,$p' |gawk '{print $2}'` 
          echo $ptilFN $ptil $AvOfNeighbors $avABSlag >> tmp.otpt.$$
        end
        cat tmp.otpt.$$ |\
           gawk '{printf("%s %s %f %.3f\n",$1,$2,$3,$4 )}' > $of
        sort -k3,3n $of



#D      + Select BEST based on XC, LAG and KURTOSIS Rankings
#D        . Acutally NOT USING SigStrng.  
#D            Its not a good discriminator with normalized data.
#D      (OTPT:  l.BEST.ptil.raw  and  l.BEST.ptil{passtyp}  )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set passtyp = ".normal2"; echo "## INITIAL pass ##"
        set ifXC = l.ref-test.summ"$passtyp"
        set ifKURT = l.KURTOSIS_pSTCKs"$passtyp"
        set wgtXC = 1.00; echo "USE ORG"
        set wgtKURT = 2.0; echo "USE ORG"
        set wgtLAG = 1.0; echo "USE ORG"
        echo "USE as of 150717:"
        set wgtXC = 1.00; echo "SEEMS o.k. USE"
        set wgtKURT = 2.00; echo "SEEMS o.k. USE"
        set wgtLAG = 0.500; echo "SEEMS o.k. USE"
        set ptMN = 0.200; echo "SEEMS o.k. USE"
        set ptMX = 0.800; echo "SEEMS o.k. USE"
        set mnXCbest = 0.90  
        set of = l.BEST.ptil.raw
        sort -k 3,3n $ifXC |cat -n > tmp.Rank-XC.$$
        sort -k 4,4nr $ifXC |cat -n > tmp.Rank-LAG.$$
        egrep -v '00A ' $ifKURT |sort -k 5,5nr |cat -n > tmp.Rank-KURT.$$
        gawk '{print $1}' $ifXC > tmp.lst.$$
        /bin/rm $of;  
        touch   $of;  
        foreach ptilFN (` cat tmp.lst.$$ `)
          set rnkXC = `egrep "$ptilFN" tmp.Rank-XC.$$ |gawk '{print $1,$4}'`
          set rnkKURT = `egrep "$ptilFN" tmp.Rank-KURT.$$ |gawk '{print $1,$6}'`
          set rnkLAG = `egrep "$ptilFN" tmp.Rank-LAG.$$ |gawk '{print $1,$5}'`
          echo $ptilFN $rnkXC $rnkKURT $rnkLAG |\
            gawk '{printf("%s %s %s %s  %" "2d  %" "2d  %" "2d %" "3d\n",\
              $1,$3,$5,$7,$2,$4,$6,($2+("'"$wgtKURT"'"*$4)+("'"$wgtLAG"'"*$6+0.)) )}' \
            >> $of
        end
        gawk 'BEGIN{\
          ptmn=sprintf("%.3f","'"$ptMN"'"+0. );\
          ptmx=sprintf("%.3f","'"$ptMX"'"+0. );\
          mnxcbest=sprintf("%.3f","'"$mnXCbest"'"+0. );\
        }{\
          split($1,a,"_");\
          split(a[2],b,".");\
          str=sprintf("%1s.%3s",b[1],b[2] );\
          ptil=sprintf("%.3f",str );\
          if($2+0. >= mnxcbest+0.){\
            if(ptmn+0. <= ptil+0. && ptil+0. <= ptmx+0.){\
              printf("%s %s %s %s  %" "2d  %" "2d  %" "2d %" "3d\n",\
     $1,$2,$3,$4,$5,$6,$7,(("'"$wgtXC"'"*$5)+("'"$wgtKURT"'"*$6)+("'"$wgtLAG"'"*$7+0.)) );\
            }\
          }\
        }' $of | sort -k 8,8n |tail -1 |\
        gawk '{printf("BEST ptil REF: %s\n",$0 )}' > l.BEST.ptil"$passtyp"
        echo "";\
        echo "wgtXC,wgtKURT,wgtLAG;  ptMN, ptMX, mnXCbest: ";\
        echo "$wgtXC   $wgtKURT   $wgtLAG ;  $ptMN $ptMX  $mnXCbest";\
        echo "";\
        cat l.BEST.ptil"$passtyp"


#T#S==150716: BEST TESTS
#T#S==150716: BEST TESTS
#T#S==150716: BEST TESTS
#T    # TESTS on BEST estimates for all NVTs analyzed so far
#T    # BASED on contents of files: l.BEST.ptil.raw 
#T    #   Generated so far for ~ 8 NVTs
#T    # CONCL:
#T  [ set datDIR = .... (e.g., /data/tec5/nadeau/QUADS/PRK/PSERM-PASS1 )
#T    cd $datDIR
#T    set wgtXC = 0.75; echo "SEEMS o.k. USE"
#T    set wgtKURT = 2.0; echo "SEEMS o.k. USE"
#T    set wgtLAG = 0.725; echo "SEEMS o.k. USE"
#Techo "YES Use Below"
#T    set wgtXC = 1.00; echo "SEEMS o.k. USE"
#T    set wgtKURT = 2.00; echo "SEEMS o.k. USE"
#T    set wgtLAG = 0.500; echo "SEEMS o.k. USE"
#T    set ptMN = 0.400
#T    set ptMX = 0.800
#T    foreach i (` ls D*/*D/l.B*raw `)
#T        echo "# "$i
#T        set mnXCbest = 0.90  
#T        cat $i |\
#T          gawk 'BEGIN{\
#T            ptmn=sprintf("%.3f","'"$ptMN"'"+0. );\
#T            ptmx=sprintf("%.3f","'"$ptMX"'"+0. );\
#T          }{\
#T            split($1,a,"_");\
#T            split(a[2],b,".");\
#T            str=sprintf("%1s.%3s",b[1],b[2] );\
#T            ptil=sprintf("%.3f",str );\
#T            if(ptmn+0. <= ptil+0. && ptil+0. <= ptmx+0.){\
#T              printf("%s %s %s %s  %" "2d  %" "2d  %" "2d %" "3d\n",\
#T     $1,$2,$3,$4,$5,$6,$7,(("'"$wgtXC"'"*$5)+("'"$wgtKURT"'"*$6)+("'"$wgtLAG"'"*$7+0.)) );\
#T            }\
#T          }' > zzz
#T        echo ""
#T        sort -k 8,8n zzz |\
#T          gawk '{if($2+0. >= "'"$mnXCbest"'"+0.){print $0}}' 
#T        echo ""
#T        echo "wgtXC,wgtKURT,wgtLAG;  ptMN, ptMX, mnXCbest: ";\
#T        echo "$wgtXC   $wgtKURT   $wgtLAG ;  $ptMN $ptMX  $mnXCbest";\
#T        echo "";\
#T        sort -k 8,8n zzz |\
#T          gawk '{if($2+0. >= "'"$mnXCbest"'"+0.){print $0}}' |tail -1 
#T        echo ""
#T    end
#T    ]]]
#T
#T  # CONCL: Found these values generally suitable for test cases as of 150717
#T  #   wgtXC,wgtKURT,wgtLAG;  ptMN, ptMX, mnXCbest: 
#T  #   1.00   2.00   0.500 ;  0.200 0.800  0.90
#T  # Implementing as of 150717
#T#E==150716: BEST TESTS
#T#E==150716: BEST TESTS
#T#E==150716: BEST TESTS


#D      = g) SMOOTH ptil-REF (i.e., psERM)
#D        . PYTHON code
#D        . Smooth over an swlen samples moving window
#D        . Beginning End-effect smoothing is phased in until full window length
#D        . Ending End-effect smoothing is same but phased out after full window length
#D        . Smooths over all samples, steps of 1.
#D        . Median smoothing wi each stepped swlen is used  
#D              + within each window use V50 
#D                ( I think this will reduce quake effects somewhat. )
#D      (OTPT: dat.PSERM_{ptil}_SMOOTH )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set swlen = 5; echo "In samples: For TESTING"
        set swlen =  50; echo "In samples:  50 ==  5-sec @ 10 sps"
        set swlen = 100; echo "In samples: 100 == 10-sec @ 10 sps; USED"
        set passtyp = ".normal2"; echo "## INITIAL pass ##"
        set if = l.BEST.ptil"$passtyp"
        set of = dat.ptil-REF_0.662_SMOOTH
        set FN = `cat $if |gawk '{print $4}'`
        set ptil = `echo $FN |gawk '{split($1,a,"_");print substr(a[2],1,5)}'`
        $spy2; echo "source shared libraries for PYTHON 2"
        "$utl"/m_tsSMOOTH-median.py $swlen $FN > dat.PSERM_"$ptil"_medSMOOTH
#mkDAT stop
endif


echo "A5555"


#DS===:: OPTIONAL ::
#DS===:: OPTIONAL ::
      if ( "$mkPLOTs" == "Y" ) then


          # PLOT Unsmoothed and smoothed PSERM
          cd $datDIR
          cd DAT_"$NVTID"
          cd DAT.TRMD

          set passtyp = ".normal2"; echo "## INITIAL pass ##"
          set nvtSTRT = `gawk '{printf("%s",$1 )}' cat.*_detect-INFO`
          set nvtEND  = `gawk '{printf("%s",$3 )}' cat.*_detect-INFO`
          set sT = `caldate -- $nvtSTRT -5M`
          set eT = `caldate -- $nvtEND  +5M`
echo "OUCH0"
          set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
          set ptil = `cat l.BEST.ptil"$passtyp" |gawk '{split($4,a,"_");print substr(a[2],1,5)}'`
          set ifSMTH = dat.PSERM_?.???_medSMOOTH
echo "OUCH1"
          set ifNOTsmthd = `cat l.BEST.ptil"$passtyp" |gawk '{print $4}'`
          set if = dat.vlp-stack-srtd_0.541.normal2_TRUNC
          foreach if ($ifNOTsmthd $ifSMTH)
            sort -k 1,1n $if > tmp.srtd.$$
            set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
            set MIN = `sed -n '1,1p' tmp.srtd.$$`
            set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
            set P98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
            set NORM = `echo "$P98 $MIN" |gawk '{printf("%f", $1-$2 )}'`
            gawk '{printf("%lf\n",($1-"'"$MIN"'")/("'"$NORM"'"+0.) )}' $if > "$if".tmp
            $utl/mGplt.psERM "$if".tmp  $pLEN
            /bin/rm "$if".tmp
            if ( "$if" == "$ifSMTH" ) then
              mv myp2 myp.psERM_medSMOOTH.ps
            endif
            if ( "$if" == "$ifNOTsmthd" ) then
              mv myp2 myp.psERM_notSMOOTH.ps
            endif
         end


      endif
      if ( "$vuPLOTs" == "Y" ) then
        cd $vuPLTdir
        gv myp.psERM_notSMOOTH.ps
        gv myp.psERM_medSMOOTH.ps
      endif
#DE===:: OPTIONAL ::
#DE===:: OPTIONAL ::


echo "A6666"


if ( "$mkDAT" == "Y" ) then
#D      = h) LRGseg: High Signal portion of psERM
#D        . PYTHON code
#D        . Use Smoothed psERM
#D        . Look for swlenM portion of psERM with highest signal as measured by:
#D           + Minimum KURTOSIS --> broader distribution 
#D             --> more high-low contrast for XCs
#D           + KURTOSIS = (1/2)*(P75-P25)/(P90-P10)
#D        . Start search 15 sec before through 15 sec after nvt detection
#D           + that is 1st sample of swlenM starts 15 sec before 
#D             and  last sample of swlenM ends 15 sec after detection period
#D        . ts0    == refers to the starting time of the time-series.
#D        . durM   == duration of the NVT detection period in fractional minutes.
#D        . durSMP == duration of the NVT detection period in samples (assuming given _SPSvlp_)
#D        . srchS  == sample number from ts0 starting pmSMP before start of NVT dectection period.
#D        . srchE  == sample number from ts0 ending   pmSMP after  end   of NVT dectection period.
#D        . minS   == minutes.frac  from ts0 starting pmSMP before start of NVT dectection period.
#D        . minE   == minutes.frac  from ts0 ending   pmSMP after  end   of NVT dectection period.
#D        . swlenMmx is in minutes
#D        . swlen    is in samples
#D        . IF  nvt duration (durM) > swlenMmx, use: swlen == swlenMmx[in smps@SPSvlp] to search for LRGamp portion.
#D              1) List: swlen == swlenMmx[in min.] as window length used.
#D              2) List: (minS,minE,smpS,smpE) as values output by prog:  _mLRGvlp-search_mad.py_
#D        . IF  nvt duration (durM) < swlenMmx, do not search, and 
#D              1) List: swlen == (srchE-srchS)[in min.] as window length.
#D              2) List: (minS,minE,smpS,smpE) as values corresponding to  _srchS_ and _srchE_
#D                 (i.e., basically the entire nvt trigger period -pmSMP at beginning and +pmSMP at end)
#D        . vlp starts 5 min before tremor starts (per trimming above)
#D        . stp interval is 1 smp for search
#D      (OTPT: l.PSERM_{ptil}_LRGseg-info.{swlenMmx}min )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set passtyp = ".normal2"
        set infoFN = l.BEST.ptil"$passtyp"
        set SPSvlp = 10
        set pmSMP = 150; echo "(15 sec at 10 sps)"
        set swlenMmx = 15; echo "minutes USED for kurtosis method"; 
        set swlenMmx = 10; echo "minutes TEST using _mad_ method";
        set ptil = `cat "$infoFN" |gawk '{split($4,a,"_");print substr(a[2],1,5)}'`
        set if = dat.PSERM_"$ptil"_medSMOOTH
        set of = lll; echo "For Testing"
        set of = l.PSERM_"$ptil"_LRGseg-INFO."$swlenMmx"min
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set dM = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$1)}'`
        set dS = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$2)}'`
        set dF = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$3)}'`
        set durM = `echo "$dM $dS $dF" |gawk '{printf("%f",($1+(($2+($3/10000))/60.)) )}'`
        set durSMP = \
          `echo "$dM $dS $dF $SPSvlp" |gawk '{printf("%d",($1*60*$4)+($2*$4)+(($3/10000)*$4) )}'`
        set srchS = `echo "5. 60. $SPSvlp $pmSMP" |gawk '{printf("%d",($1*$2*$3)-$4 )}'`; echo "strt 5 min after smp0 - pmSMP"
        set srchE = `echo "$srchS $durSMP $pmSMP" |gawk '{printf("%d",($1+$2)+(2.*$3) )}'`
        set SKP = `echo $durM $swlenMmx |gawk '{if($1+0. > $2+0.){print "OFF"}else{print "ON"}}'`
        if ( "$SKP" == "OFF" ) then
          set swlen = `echo "$swlenMmx 60 $SPSvlp" |gawk '{printf("%d",$1*$2*$3 )}'`
          echo "00A segDUR(min) minS    minE   smpS  smpE kurtosis     MAD         FN" \
            > $of
          "$utl"/mLRGvlp-search_mad.py $srchS $srchE $swlen $SPSvlp $if  |\
            sort -k 6,6n  |sed -n '$,$p' |\
            gawk '{printf("%+11s    %s  %s  %s  %s %s %s   %s\n", \
              "'"$swlenMmx"'",$1,$2,$3,$4,$5,$6,"'"$if"'" )}' \
              >> $of
        endif
        if ( "$SKP" == "ON" ) then
          echo "00A segDUR(min) minS    minE   smpS  smpE kurtosis     MAD         FN" \
            > $of
          set minS = `echo $srchS |gawk '{printf("%.4f",($1/10.)/60. )}'` 
          set minE = `echo $srchE |gawk '{printf("%.4f",($1/10.)/60. )}'` 
          set segDUR_M = \
            `echo $srchE $srchS |gawk '{printf("%.4f", ($1-$2)/("'"$SPSvlp"'"*60.) )}'`
          echo "     $segDUR_M    $minS  $minE  $srchS  $srchE NO_kurtosis  NO_MAD   $if" \
            >> $of
        endif
        cat $of


#D    ============================
#D    + Rank ORIGINAL vlps based on XC with ptil-REF:
#D    ============================
#D       = FIRST TRUNCATE all chn ts 
#D         + TRUNCATION STABALIZES XC COMPUTATION
#D         + (USE ptilTRUNC == 0.993; see: src_RM.proc)
#D         + FOR EXAMPLE for 10 sps vlp data (i.e., 10200 samples in 17 min.):
#D           ptilTRUNC == 0.993 --> ~ 7 sec.
#D      (OTPT: {chnFN}_TRUNC  )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set passtyp = ""; echo "## INITIAL pass ##"
        set ptilTRUNC = 0.993; echo "USE THIS corresponds to 10 min. of truncation for 24 hr data"
                               echo "Corresponds to 10 sec. of truncation for 24 mins. data"
        ls *.??.Bf?*.D.*"$NVTID".*.vlp.ascii |\
          sed -n '1,$p' > tmp.list.$$
        foreach chnFN (` cat tmp.list.$$ `)
          echo "$chnFN"
          set Nsmp = `wc $chnFN |gawk '{printf("%d",$1)}'`
          sort -k 1,1n $chnFN |\
          cat -n  |\
          gawk 'BEGIN{Nsmp=sprintf("%d","'"$Nsmp"'"+0)}{\
            printf("%d %f %f\n",$1+0,($1/Nsmp)+0.,$2+0. );\
          }' > tmp.srtd.$$
        echo "## Now get the ptilTRUNC value and  Truncate ts ##"
          set pTRUNCnum = `echo $Nsmp $ptilTRUNC |gawk '{printf("%d\n",$1*$2 )}'`
          set pTRUNCval = `sed -n ''"$pTRUNCnum"'p' tmp.srtd.$$ |gawk '{printf("%f",$3+0. )}'`
          gawk 'BEGIN{pTval=sprintf("%f","'"$pTRUNCval"'"+0.)}{\
            val=sprintf("%f",$1+0.);\
            if(val+0. <= pTval+0.){\
              printf("%f\n",val+0.);\
            }else{\
              printf("%f\n",pTval+0.);\
            }\
          }' $chnFN > "$chnFN"_TRUNC
        end



#D      = b) XC with ptilSTACK
#D         . TRUNCATION STABALIZES XC COMPUTATION
#D         . starts 15 sec before detection start (implicit in l.PSERM_*_LRGseg-INFO* file) 
#D      (OTPT:  otpt.XCs.w.ptilSTACK{passtyp}  )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set passtyp = ".normal2"; echo "## INITIAL pass ##"
        set infoFN = l.BEST.ptil"$passtyp"
        set ptil = `egrep -v '00A ' $infoFN |gawk '{split($4,a,"_");print substr(a[2],1,5)}'`
        set SPSvlp = 10
        set swlenMmx = 15; echo "minutes USED for kurtosis method"; 
        set swlenMmx = 10; echo "minutes TEST using _mad_ method";
  set smpS = `egrep -v '00A ' l.PSERM_"$ptil"_LRGseg-INFO."$swlenMmx"min | gawk '{printf("%d", $4+0 )}'` 
  set smpE = `egrep -v '00A ' l.PSERM_"$ptil"_LRGseg-INFO."$swlenMmx"min | gawk '{printf("%d", $5+0 )}'` 
        set swlen = `echo "$smpE $smpS" |gawk '{printf("%d",$1-$2+1 )}'`
        set strt = $smpS; 
        set stp = 15
        set mnlag = -600; set mxlag = 600; echo "__ +/- 600 lags TRIED BUT NOT WORTH IT __"
        set mnlag = -500; set mxlag = 500
        set ts1 = dat.PSERM_"$ptil"_medSMOOTH
        set of = otpt.XCs.w.ptilSTACK"$passtyp"
        /bin/rm $of; touch $of
        foreach ts2 (`ls *.??.Bf?*ascii_TRUNC |sed -n '1,$p'`)
          set lag0 = \
 `$utl/mxc.v9 $ts1 $ts2 $strt $swlen $stp $mnlag $mxlag |sort -k 5,5n |sed -n '$,$p' |gawk '{print $4}'`
          set mnlag2 = `echo $lag0 |gawk '{printf("%d\n", $1-("'"$stp"'"+2.) )}'`
          set mxlag2 = `echo $lag0 |gawk '{printf("%d\n", $1+("'"$stp"'"+2.) )}'`
          $utl/mxc.v9 $ts1 $ts2 $strt $swlen 1 $mnlag2 $mxlag2  |\
          sort -k 5,5n |sed -n '$,$p' |tee -a $of
        end
        sort -k 5,5nr $of |cat -n |sort -k 1,1nr 
        wc $of


#D        c) LOOK: Sort/Rank
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set passtyp = ".normal2"
        set if = otpt.XCs.w.ptilSTACK"$passtyp"
        sort -k 5,5nr $if |cat -n |sort -k 1,1r


#D  - PLOTs ( Combination of SEISTOOL and GMT )
#D    = PREP !!! MUST-DO !!!
#D      + Make Ranked lists
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set passtyp = ".normal2"
        set if = otpt.XCs.w.ptilSTACK"$passtyp"
        sort -k 5,5nr $if |cat -n > l.ranked.INFO
        sort -k 5,5nr $if |egrep -v '\.BP\.|\.PB\.' |cat -n > l.ranked.INFO_noBOREHOLE
        sort -k 5,5nr $if |\
          gawk '{print $2}' |\
          gawk 'BEGIN{FS=OFS="."}{\
            printf("%s.%s.%s.%s.%s.%s.%s.%s\n",$1,$2,$3,$4,$5,$6,$7,$8 );\
          }' > l.ranked.wfIDs
        /bin/rm l.ranked.wfFNs l.ranked.vlpFNs \
                l.ranked.wfFNs_noBOREHOLE l.ranked.vlpFNs_noBOREHOLE
        touch   l.ranked.wfFNs l.ranked.vlpFNs \
                l.ranked.wfFNs_noBOREHOLE l.ranked.vlpFNs_noBOREHOLE
        foreach i (`cat l.ranked.wfIDs `)
          ls "$i".trmd >> l.ranked.wfFNs
          ls "$i".trmd |egrep -v '\.BP\.|\.PB\.' >> l.ranked.wfFNs_noBOREHOLE
          ls "$i"*.vlp.trmd >> l.ranked.vlpFNs
          ls "$i"*.vlp.trmd |egrep -v '\.BP\.|\.PB\.' >> l.ranked.vlpFNs_noBOREHOLE
        end
        ls -l *0000.trmd |gawk '{if($5+0. > 0.+0.){print $9}}' \
                            > l.ranked-NOT.wfFNs
        ls *.vlp.trmd > l.ranked-NOT.vlpFNs
        wc l.ranked*



#D          = Modification to lists for SOH (STAFF MEETINGS)
            cd $datDIR
            cd DAT_"$NVTID"
            cd DAT.TRMD
            set if = l.ranked.INFO_noBOREHOLE
            set of = l.ranked.CHN-XC_noBOREHOLE.txt
            gawk '{\
              split($3,aa,".");\
              printf("%" "2d %-12s %0.3f\n",$1, aa[1]"."aa[2]"."aa[3],$NF );\
            }' $if |tee $of
            egrep '\.BK\.' $of |tee l.ranked.CHN-XC_noBOREHOLE-BK.txt
#mkDAT stop
endif


echo "A7777"
  

#DS===:: OPTIONAL ::
#DS===:: OPTIONAL ::
      if ( "$mkPLOTs" == "Y" ) then


#D      = SUITE of ALL RANKED vlps and wfs :  NORMALIZED
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD
        set passtyp = ".normal2"
        set vlpINFO = l.ranked.INFO
        set wfINFO = l.ranked.wfFNs
        set inclERM = "N"; echo "Include the PSERM:  no"
        set inclERM = "Y"; echo "Include the PSERM: yes"
        if ( "$inclERM" == "Y" ) then
          sed -n '$,$p' $vlpINFO |\
            gawk '{printf("  1 %s %s %s 0000 1.00000\n",$2,$2,$4 )}' > tmp.$$
          gawk '{printf("%" "3d %s %s %s %s %s\n",($1+1),$2,$3,$4,$5,$6 )}' \
            $vlpINFO  >> tmp.$$
          set vlpINFO = tmp.$$
        endif
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
        set sT = `caldate -- $nvtSTRT -5M`
        set eT = `caldate -- $nvtEND  +5M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
   echo "# VLPS NORMALIZED"
        set Ntrc = `wc $vlpINFO |gawk '{print $1}'` 
        gawk 'BEGIN{i=0+0}{\
          i=i+1;\
          fn[i]=sprintf("%s",$3 );\
        }END{\
          for(j=i;j>0;j--){\
            print fn[j];\
          }\
        }' $vlpINFO > tmp.lst.vlps.$$

        /bin/rm pltdat.SUITE.vlps;  touch pltdat.SUITE.vlps
        set iTRC = `echo $Ntrc |gawk '{printf("%d",$1+1. )}'`
        foreach if (` cat tmp.lst.vlps.$$ |sed -n '1,$p' `)
          sort -k 1,1n $if > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1. )}'`
          gawk 'BEGIN{\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
            printf("%lf\n",(-1.5*($1-shft)/rng)+(itrc+0.) ) ;\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE.vlps
        end

   echo "# WFs NORMALIZED"
        set DECIMATE = 2
        set DECIMATE = 5
        set DECIMATE = 10
        set SPSwf = 20; 
        set SPSwfPLT = `echo $SPSwf $DECIMATE |gawk '{printf("%d",int(($1/$2)+0.5) )}'`
        set Ntrc = `wc $wfINFO |gawk '{print $1}'` 
        gawk 'BEGIN{i=0+0}{\
          i=i+1;\
          gsub(".trmd",".ascii");\
          fn[i]=sprintf("%s",$1 );\
        }END{\
          for(j=i;j>0;j--){\
            print fn[j];\
          }\
        }' $wfINFO > tmp.lst.wfs.$$
        /bin/rm pltdat.SUITE.wfs;  touch pltdat.SUITE.wfs
        set iTRC = `echo $Ntrc |gawk '{printf("%d",$1+1. )}'`
        foreach if (` cat tmp.lst.wfs.$$ |sed -n '1,$p' `)
          set DC = `$utl/mav $if |gawk '{printf("%lf\n",$6+0. )}'`
          gawk '{printf("%lf\n",($1-"'"$DC"'")+0. )}' $if \
          > tmpx.$$
          sort -k 1,1n tmpx.$$ > tmp.srtd.$$
          set Nsmp = `wc tmp.srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1. )}'`
          gawk 'BEGIN{\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
            if( (NR % decim) == 1+0 ){\
              printf("%lf\n",(-0.7*($1)/rng)+(itrc+0.) ) ;\
            }\
          }END{\
            print "sss";\
          }' tmpx.$$ >> pltdat.SUITE.wfs
        end
        "$utl"/mGplt.ptil-SUITE-RANKED  $inclERM  $Ntrc  $pLEN  $SPSwfPLT \
                                        pltdat.SUITE.vlps  pltdat.SUITE.wfs  
        mv myp2 myp.ptil-SUITE-RANKED.ps
 
#DSS--Quick Just VLPs
#D        "$utl"/mGplt.ptil-SUITE-RANKED  $inclERM  $Ntrc  $pLEN  $SPSwfPLT \
#D                                        pltdat.SUITE.vlps  pltdat.SUITE.vlps
#D         mv myp2 myp.ptil-SUITE-RANKED.ps
#D        ]]]
#DEE--Quick Just VLPs


      endif
      if ( "$vuPLOTs" == "Y" ) then
        cd $vuPLTdir
        gv  myp.ptil-SUITE-RANKED.ps
      endif
#DE===:: OPTIONAL ::
#DE===:: OPTIONAL ::


echo "A8888"


#DS===:: OPTIONAL :: SEISTOOL::
#DS===:: OPTIONAL :: SEISTOOL::
#D        ### CRUST MANTLE ###
#D        ### CRUST MANTLE ###
#D        ### CRUST MANTLE ###
#D          # w/ SEISTOOL #
#D          # w/ SEISTOOL #
#D          . Seistool has a maximum wf limit for display before messing up
#D          . So limiting to 83 of 84 wfs
#D      [ set datDIR = .... (e.g., /data/tec5/nadeau/QUADS/PRK/PSERM-PASS1 )
#D        cd $datDIR
#D        set utl = /data/hrsn1/hfn6/nadeau/PACKAGES/PSERM/UTL
#D        set NVTID = 2015.085,19:17:25.0000
#D        set NVTID = 2015.087,12:10:51.0000
#D        cd DAT_"$NVTID"
#D        cd DAT.TRMD
#D        set if = l.ranked-NOT.vlpFNs
#D        set if = l.ranked-NOT.wfFNs_noBOREHOLE; 
#D        set if = l.ranked.wfFNs_noBOREHOLE; 
#D        set if = l.ranked.vlpFNs_noBOREHOLE
#D        set if = l.ranked-NOT.wfFNs
#D        set if = l.ranked.wfFNs
#D        set if = l.ranked.vlpFNs
#D        set Nwf = "65"
#D        set Nwf = `wc $if |gawk '{printf("%d",$1+0 )}'`
#D        seistool -el $if -numtr "$Nwf" -numztr "$Nwf"
#D        ]]]
#D
#D
#D        + SAVE snapshot
#D 
#D        + CONVERT snapshot to *.ps
#D        [ set rtFN = 2015.085.NVT.abs.rank-NOT.wf
#D        [ set rtFN = 2015.085.NVT.rel.rank-NOT.wf
#D        set Nwf = "65"
#D        set Nwf = `wc $if |gawk '{printf("%d",$1+0 )}'`
#D        seistool -el $if -numtr "$Nwf" -numztr "$Nwf"
#D        ]]]
#D
#D        + SAVE snapshot
#D 
#D        + CONVERT snapshot to *.ps
#D        [ set rtFN = 2015.085.NVT.abs.rank-NOT.wf
#D        [ set rtFN = 2015.085.NVT.rel.rank-NOT.wf
#D        [ set rtFN = 2015.085.NVT.rel.rank.vlp
#D        [ set rtFN = 2015.085.NVT.rel.rank.wf
#D        [ set rtFN = 2015.085.NVT.rel.rank-NOT.vlp
#D        [ set rtFN = 2015.087.NVT..........
#D          set if = "$rtFN".tiff
#D          set of = "$rtFN".ps
#D          tiff2ps $if > $of
#D          gv $of
#D          ]]]
#DE===:: OPTIONAL :: SEISTOOL::
#DE===:: OPTIONAL :: SEISTOOL::
          


if ( "$mkDAT" == "Y" ) then
#D  ====================================================
#D  - MAP: Stations color coded to XC and LAGs w/ psERMS  
#D  ====================================================
#D    + Color scale ranking of XCs w/  psERMs
#D    + FOR NOW:
#D      . Only have STN.NT info  (i.e., Don't have 
#D          full channel names of starting data
#D      . So for now am making best guess
#D    + Station info from:
#D        /data/dc6/ftp/pub/doc/...
#D    + Rank info from:
#D        otpt.XCs.w.ptilSTACK{passtyp}
#D    + Plotting info from:
#D      =COLOR=
#D        DIR:
#D         /data/hrsn1/hfn6/nadeau/13.PWP-2013/MS/FIGS/F.cD-T
#D        FILES:
#D         RM.proc
#D           and 
#D         /UTL/mGplt.cD-Y_clr_NSF.GP14
#D      =STNs w/ NAMES=
#D        DIR:
#D         /data/hrsn1/hfn6/nadeau/MEETINGS/BIDS/BIDS.1505/F.THOUSANDSofCHANs
#D        FILES:
#D         RM.proc
#D           and 
#D         ../UTL/map.STNs
#D        
#D  = Get Station Location info
#D     - STARTING META DATA (UPDATE as needed)
#D       + Use:  {NT}.simple.responses  and  {NT}.channel.summary.doy
#D       + {NT} are: NC,BK,BP,PB,BG,TA,WR,PG and CI
#D       + Velocity
#D       + Not CN? BN? LN? (these are short-term miswired CMAB station records)
#D       + In operation YD of tremor
#D       + No redundant locations
#D     - PLAN:
#D       a) VLP STN.NT:
#D          . OTPT --> fgrp-vlps.$$
#D       b) VELOCITY STN.NT.CHN.LCs:
#D          . Day
#D          . Velocity channels
#D          . STN.NT from a) only (use: fgrp-vlps.$$ from above)
#D          . OTPT --> fgrp-vlp-veloc.$$
#D       c) LOCATION STN.NT.CHN.LCs:
#D          . Day
#D          . Sample Rate Not Zero (ie. column 5 == 0.0 )
#D          . Unique locations
#D          . STN.NT from a) only (use: fgrp-vlps.$$ from above)
#D          . OTPT --> fgrp-vlp-loc.$$
#D       d) VELOCITY-LOCATION STN.NT.CHNs: 
#D          . Common STN.NT.CHN.LCs from b) and c) above 
#D              (use: fgrp-vlp-veloc.$$ and fgrp-vlp-loc.$$ )
#D          . OTPT --> fgrp-vlp-veloc-loc.$$
#D       e) Final station location info
#D          . FORMAT: STN.NT Lat Lon Depth
#D
#D  (OTPT:  l.STN.NT_LOCS )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD
    set dir = /data/dc6/ftp/pub/doc
    set passtyp = ".normal2"
    set rnkFN = otpt.XCs.w.ptilSTACK"$passtyp"
 echo "VLP STN.NT" 
    gawk '{split($2,a,".");printf("^%-6s%2s \n",a[1],a[2] )}' $rnkFN |sort > fgrp-vlps.$$
    set YD = `echo "$NVTID" |gawk '{printf("%.3f", substr($1,1,8) )}'`
 echo "VELOCITY CHANNELS" 
    cat "$dir"/NC.info/NC.simple.responses \
        "$dir"/BK.info/BK.simple.responses \
        "$dir"/BP.info/BP.simple.responses \
        "$dir"/PB.info/PB.simple.responses \
        "$dir"/BG.info/BG.simple.responses \
        "$dir"/TA.info/TA.simple.responses \
        "$dir"/WR.info/WR.simple.responses \
        "$dir"/PG.info/PG.simple.responses \
        "$dir"/CI.info/CI.simple.responses |\
       egrep -v ' CN[123] | BN[123] | LN[123] ' |\
       gawk 'BEGIN{yd=sprintf("%.3f","'"$YD"'"+0. )}{\
         mnYD = substr($5,1,8);\
         mxYD = substr($6,1,8);\
         if(mnYD+0. <= yd+0. && yd+0. <= mxYD+0.){\
           if($NF == "DU/M/S"){\
             SNCL=sprintf("%-6s%2s %s %s",$2,$1,$3,$4 );\
             printf("%s \n",SNCL);\
           }\
         }\
       }' |sort -u |\
       egrep -f fgrp-vlps.$$ > fgrp-veloc.$$

 echo "LOCATION CHANNELS" 
     cat "$dir"/NC.info/NC.channel.summary.doy \
         "$dir"/BK.info/BK.channel.summary.doy \
         "$dir"/BP.info/BP.channel.summary.doy \
         "$dir"/PB.info/PB.channel.summary.doy \
         "$dir"/BG.info/BG.channel.summary.doy \
         "$dir"/TA.info/TA.channel.summary.doy \
         "$dir"/WR.info/WR.channel.summary.doy \
         "$dir"/PG.info/PG.channel.summary.doy \
         "$dir"/CI.info/CI.channel.summary.doy |\
       sed 's/\,/\./g' |\
       gawk 'BEGIN{yd=sprintf("%.3f","'"$YD"'"+0. )}{\
         mnYD = substr($6,1,8);\
         mxYD = substr($7,1,8);\
         rate = sprintf("%.7f",$5+0. );\
         if(mnYD+0. <= yd+0. && yd+0. <= mxYD+0.){\
           if(rate+0. > 0.0000000){\
             print $0;\
           }\
         }\
       }' |sort -u -k 8,11 > tmp.tmp.$$
       gawk '{\
         SNCL=sprintf("%-6s%2s %s %s",$1,$2,$3,$4 );\
         printf("%s \n",SNCL);\
       }' tmp.tmp.$$ |sort -u |\
       egrep -f fgrp-vlps.$$ > fgrp-loc.$$
 echo "VELOCITY and LOCATION"    
       comm -12 fgrp-veloc.$$ fgrp-loc.$$ |\
         gawk '{\
           SNCL=sprintf("%-6s%2s %s %s",$1,$2,$3,$4 );\
           printf("^%s \n",SNCL);\
         }' > fgrp-vlp-veloc-loc.$$
       head fgrp-vlp-veloc-loc.$$
       egrep -f fgrp-vlp-veloc-loc.$$  tmp.tmp.$$ |\
         gawk '{\
           SN=sprintf("%s.%s", $1,$2 );\
           dpthKM=sprintf("%.5f", $11/1000. );\
           printf("%-9s %8.5f %10.5f %f\n",\
                   SN,$8,$9,dpthKM );\
         }' |tee  l.STN.NT_LOCS 
       wc l.STN.NT_LOCS  $rnkFN



#D  = Add XC-RANK, LAGs, and NVT_duration to station location list
#D  (OTPT:  l.STN.NT_LOCS_XC-RANK_LAG_DUR )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD
    set nvtSTRT = `gawk '{printf("%s",$1 )}' cat."$NVTID"_detect-INFO`
    set nvtEND  = `gawk '{printf("%s",$3 )}' cat."$NVTID"_detect-INFO`
    set dM = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$1)}'`
    set dS = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$2)}'`
    set dF = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$3)}'`
    set durM = `echo "$dM $dS $dF" |gawk '{printf("%f",($1+(($2+($3/10000))/60.)) )}'`
    set passtyp = ".normal2"
    set stnFN = l.STN.NT_LOCS
    set rnkFN = otpt.XCs.w.ptilSTACK"$passtyp"
    gawk '{print $1}' $stnFN > tmp.stn.nt.$$
    /bin/rm tmp.otpt.$$;  touch tmp.otpt.$$
    foreach stn (` cat tmp.stn.nt.$$ `)
      set xc = `egrep " $stn" $rnkFN |gawk '{print $NF}'`
      set lag = `egrep " $stn" $rnkFN |gawk '{print $(NF-1)}'`
      egrep "^$stn" $stnFN |\
        gawk '{printf("%s %s %" "4d %s\n",\
                       $0,"'"$xc"'","'"$lag"'","'"$durM"'" )}' >> tmp.otpt.$$
    end
    echo "00A STN.NT  lat.      lon.    depth(km)    XC  LAG   NVTdur(min)" \
      > l.STN.NT_LOCS.w.XC-RANK_LAG_DUR
    sort -k 5,5nr tmp.otpt.$$ >> l.STN.NT_LOCS.w.XC-RANK_LAG_DUR
    head -30 l.STN.NT_LOCS.w.XC-RANK_LAG_DUR
    /bin/rm tmp.otpt.$$
#mkDAT stop
endif


echo "A9999"

    
#DS===:: OPTIONAL ::
#DS===:: OPTIONAL ::
      if ( "$mkPLOTs" == "Y" ) then


#D  = PLOT  XC  as color
#D    + Adaptive:
#D      . Map center is center of LL ' Range ' (not average) of stations
#D      . Size of region should be fixed ito Range of degrees
#D      . Station names included (either STN or STN.NT)
#D      . Color scaling to xc-rank included:
#D          _Hot colors for High XC (e.g. red)
#D          _Cold colors for low XC (e.g. blue)
#D      . Cut-off stations below the cut-off (e.g., indicating
#D          they unlikely to be useful ) are plotted as 
#D          BLACK or GREY.
#D          - Gives PICTURE of likely AZIMUTHAL COVERAGE
#D      . Scale size of symbols to NVT duration.
#D      . ? square ==> TScope
#D      . ? triangle ==> borehole
#D      . ? circle ==> other   
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD
    set if = l.STN.NT_LOCS.w.XC-RANK_LAG_DUR
 echo "CENTER" 
    egrep -v '00A ' $if > tmp.$$
    set mnLTstn = `sort -k 2,2n tmp.$$ |sed -n '1,1p' |gawk '{print $2}'`
    set mxLTstn = `sort -k 2,2n tmp.$$ |sed -n '$,$p' |gawk '{print $2}'`
    set mnLNstn = `sort -k 3,3n tmp.$$ |sed -n '1,1p' |gawk '{print $3}'`
    set mxLNstn = `sort -k 3,3n tmp.$$ |sed -n '$,$p' |gawk '{print $3}'`
    set cLT = `echo $mxLTstn $mnLTstn |gawk '{printf("%f",$2+($1-$2)/2. )}'`
    set cLN = `echo $mxLNstn $mnLNstn |gawk '{printf("%f",$2+($1-$2)/2. )}'`
    set dLT = 1.3; echo "degrees"
    set dLN = 1.5; echo "degrees"
    set mnLT = `echo $cLT $dLT |gawk '{printf("%f",$1-$2+0. )}'`
    set mxLT = `echo $cLT $dLT |gawk '{printf("%f",$1+$2+0. )}'`
    set mnLN = `echo $cLN $dLN |gawk '{printf("%f",$1-$2+0. )}'`
    set mxLN = `echo $cLN $dLN |gawk '{printf("%f",$1+$2+0. )}'`
    set cutXC = "-1.0"
    set cutXC = "0.5";  echo "QUICK LOOK for LIKELY AZIMUTHAL COVERAGE "
    set cutXC = "0.4";  echo "QUICK LOOK corresonding to Range of Color Scale (0.4-1.0)"
echo $mnLTstn $cLT $mxLTstn $mnLNstn $cLN $mxLNstn $mnLT $mxLT $mnLN $mxLN
    egrep -v '00A ' $if|\
      gawk '{\
        if($5+0. <= "'"$cutXC"'"+0.){$5="NaN"}\
          print $1,$2,$3,$5,$7;\
      }' |sort -n -k 4,4n |tee tmp.SN.LL.XC.DUR.$$ |head -10
    gawk '{\
      printf("%f %f 07 0 00 LM %s\n",($3+0.07),$2,$1 );\
    }' tmp.SN.LL.XC.DUR.$$  |tee txtFN1.$$ |head -3
    "$utl"/map.STNs_color-size $mnLT $mxLT $mnLN $mxLN $cLT $cLN \
                               tmp.SN.LL.XC.DUR.$$ txtFN1.$$
    mv myp2 myp.MAP.ps


      endif
      if ( "$vuPLOTs" == "Y" ) then
        cd $vuPLTdir
        gv  myp.MAP.ps
      endif
#DE===:: OPTIONAL ::
#DE===:: OPTIONAL ::

echo "B0000"


if ( "$mkDAT" == "Y" ) then
#D  = XC_LAG:  OUTLIER  CHECK 
#D    + Idea is that at some level of decreasing XCs,
#D        the Lags will start to become unreliable.
#D    + Also, at some point some sweeps at large lags may
#D        give a higher XC but are inaccurate 
#D        (e.g., phase-skips analogous to cycle-skips )
#D    + Aims are to: 
#D        . Get a sense of the XC level where lags from XCs become inaccurate.
#D        . Decide/refine a better range of mnlag/mxlags might be 
#D          (to save time and reduce likelyhood of phase-skip behavior).
#D        . To possibly flag some outliers with high XC but outlier lags.
#D    + Adaptive:
#D      . Center is center of LL ' Range ' (not average) of stations (i.e., cLT and cLN)
#D      . Station names included (either STN or STN.NT)
#D    + Conversion Local coord system (LLD --> XYD) 
#D        where center is cLT and cLN defined above and WoN is 40-degrees
#D
#D
#D##  = GRID SEARCH IS USED to find first order estimate of
#D##   source location based on assumed single source at
#D##   origin time and a single average velocity.
#D##  = MAIN ASSUMPTION: Theoretically, given perfect knowledge of velocity
#D##                     and perfect 'at' (arrival time) measurements, 
#D##                     the estimate of ot from any station using ot=at-tt
#D##                     should be same. Actual value of ot is not considered,
#D##                     rather, we try to minimize the scatter in ot estimates
#D##                     using an assumed velocity and grid-searching a range
#D##                     of oXs, oYs and oDs.
#D##  = BASED ON:  at = tt + ot   for a single source 
#D##    . at (arrival time) is measured 
#D##    . ot (origin time) should theoretically be fixed (i.e., it is for the single source)
#D##    . tt (travel time) is estimated using | (xyd)_stn - (xyd)_grid-point |/ vel 
#D##    . vel is assumed constant along entire travel path.
#D##  = Arrival time at station (at_si) equals travel time (tt) + origin time (ot)
#D##    . at_si == tt_si + ot
#D##    . at_si == delX/vel + ot
#D##    . at_si == (Xi-Xo)/vel
#D##    . ot == at_si - (Xi-Xo)/vel, where
#D##       Xo is (cLT,ClN,25km) and vel is some reasonable half-space velocity
#D##  = Idea is:
#D##    + Find grid point (source location) with minimum IQR of ot estimates
#D##        from more reliable (high XC) stations.
#D##  = This location (and outlw and outhg) will be used later
#D##      to identify outliers based on the fourth spread (box-plot) method
#D##      of my Devore  stats book.
#D##
#D##  For example execution and inputs See: /data/hrsn1/hfn6/nadeau/PACKAGES/PSERM/RM.stp1.v2.proc
#D##
#D##
#D## NADEAU -- 150612
#D##   = Want to allow more data into the search, esp. since some NVTs may
#D##       not have many data at higher XC levels (e.g. above 0.7).
#D##   = That means, we need to lower mnXC
#D##   = However, that allows more spurious data into the process and
#D##       can dramatically increase IQR.
#D##   = This can lead to inclusion of more (and spurious) grid points
#D##       and grid points with lowest IQRs can be totally anamalous.
#D##   + Using multi-pass solution where first pass identifies fourth spread (fs) outliers
#D##       and removes them.
#D##   + Then process is repeated again times until
#D##      --> either no change in number of data after fs-filtering occurs between iterations
#D##      --> OR, a minumum of (Ndat?=5) stations are left (min,q1,med,q3,max):
#D##          smp_min=((N-1)*(0.0))+1 = 1, where 0.0 is 0%ile
#D##          smp_q1=((N-1)*(0.25))+1 = 2, where 0.25 is 25%ile
#D##          smp_med=((N-1)*(0.50))+1 = 3, where 0.50 is 50%ile
#D##          ...
#D##          smp_max=((N-1)*(1.00))+1 = 5, where 1.00 is 100%ile
#D
#D       ...
#D   
#D
#D   +++++++++ GRID SEARCH +++++++++++++
#D   +++++++++ GRID SEARCH +++++++++++++
#D   +++++++++ GRID SEARCH +++++++++++++
#D
#D  =======VEL ESTIMATION TESTs===========
#D  + Idea here is to use differential arrival-time information
#D      among station pairs, the locations of the stations, and an
#D      assumed grid point (source) location to derive estimates of average
#D      Velocity among travel paths to an initial set of reliable (based on XC)
#D      stations.
#D  + Relevant equations are:
#D      at_i == arrival time at station i
#D      tt_i == travel time between source and station i
#D      x_i  == distance from source (gp) to station i
#D      ot == origin time (source time, same for all)
#D      v  == velocity  (half-space, and assumed constant for all travel paths)
#D      tt_i = (x_i/v)
#D      at_i = ot + tt_i
#D      at_i = ot + (x_i/v)
#D      ot = at_i - (x_i/v)
#D        Now for any station j, ot is the same as for station i, so,
#D      ot = at_j - (x_j/v)
#D        and,
#D      at_i - (x_i/v) == at_j - (x_j/v)
#D        then,
#D      (at_i - at_j) = (x_i-x_j)/v 
#D        so,
#D      v = [(x_i-x_j)/(at_i - at_j) ], 
#D        for all possible combinations of station pairs, i and j.
#D        Denoting distribution as {}, and grid point as gp, the 
#D        distribution of velocity estimates for all possible station
#D        pairs for a single grid-point is:
#D      {Vest}gp = [(x_i-x_j)/(at_i - at_j)]gp
#D        We take the median of {Vest}gp as a reasonable estimate
#D          of the half-space velocity given the gp location.
#D        We also consider the degree of spread (IQR) and number
#D          of station i,j pairs yielding Vest within reasonable
#D          bounds (i.e., 2.5 to 3.75 km/s) as a guide for identifying
#D          viable gp's for consideration in the subsequent oT grid-search.
#D       Also travel paths between pairs must be >= _mnSEP_
#D  + PLAN:  
#D    . First cycle through grid points and identify those
#D      that have reasonable (Vel:2.5 to 3.75 km/s, hardwired into program: mVest.stats)
#D      and reasonably stable velocities with the xc (initially) relaiable
#D      stations (see below).
#D    . THEN ONLY perform oT grid search (below) on those gp's that pass the velocity
#D      gp analysis.  
#D    . Also use the Vest from the present search for the subsequent oT grid search
#D    . Also travel paths between pairs must be >= _mnSEP_
#D
#D
#D  = Vest-LOOP: Find gp's with vialble Vest's
#D  (OTPT:  of1:  l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL )
#D  (OTPT:  of2:  l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-{mnXCf} )
#D  (OTPT:  of3:  dat.gp-search.Vest.one )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set runt0 = `date +%Y.%j,%T`
    set if = l.STN.NT_LOCS.w.XC-RANK_LAG_DUR
    set of1 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL
 echo "CENTER of station RANGES USED, not average" 
    egrep -v '00A ' $if > tmp.$$
    set mnLTstn = `sort -k 2,2n tmp.$$ |sed -n '1,1p' |gawk '{print $2}'`
    set mxLTstn = `sort -k 2,2n tmp.$$ |sed -n '$,$p' |gawk '{print $2}'`
    set mnLNstn = `sort -k 3,3n tmp.$$ |sed -n '1,1p' |gawk '{print $3}'`
    set mxLNstn = `sort -k 3,3n tmp.$$ |sed -n '$,$p' |gawk '{print $3}'`
    set cLT = `echo $mxLTstn $mnLTstn |gawk '{printf("%f",$2+($1-$2)/2. )}'`
    set cLN = `echo $mxLNstn $mnLNstn |gawk '{printf("%f",$2+($1-$2)/2. )}'`
    set C1 = 2; set C2 = 3; set C3 = 4; set WoN = 40.0
    egrep -v '00A ' $if > tmp.$$
    "$utl"/mll2xyz_flex.v3 $C1 $C2 $C3 \
                           $cLT $cLN $WoN tmp.$$ > $of1

  echo "mnXC and mnSTNs FILTER" 
    set mnXC0 = "0.70"; set lowestXC = "0.60"; echo "kurtosis XC-window method"
    set mnXC0 = "0.75"; set lowestXC = "0.60"; echo "MAD      XC-window method--pending"
    set incXC = "0.01"
    set mnSTNs = "18"
    gawk 'BEGIN{\
      mnxc0=sprintf("%.2f","'"$mnXC0"'"+0.);\
      lowestxc=sprintf("%.2f","'"$lowestXC"'"+0.);\
      incxc=sprintf("%.2f","'"$incXC"'"+0.);\
      mnstn=sprintf("%d","'"$mnSTNs"'"+0.);\
      i=0+0;\
    }{\
      i=i+1;\
      lin[i]=$0;\
    }END{\
      nlin=sprintf("%d",i+0);\
      ndat=0+0;\
      for(mnxci=(mnxc0+0.);mnxci>=(lowestxc+0.);mnxci=sprintf("%.2f",(mnxci-incxc+0.) )){\
        for(j=1;j<=i;j++){\
          n=split(lin[j],a);\
          if(a[8]+0. >= mnxci+0.){\
            ndat=ndat+1;\
            otpt[ndat]=lin[j];\
          }\
        }\
  printf("%.2f %d %d %.2f\n", mnxci,ndat,i,(ndat/i) ) > "/dev/tty";\
        if(ndat+0 >= mnstn+0 || mnxci+0. == lowestxc+0.){\
          for(k=1;k<=ndat+0;k=k+1){\
            print otpt[k];\
          }\
          printf("%.2f %d %d %.2f\n", mnxci,ndat,i,(ndat/i) ) > "l.mnXCinfo";\
          break;\
        }\
      ndat=0+0;\
      }\
    }' $of1 > tmp.mnXC-Filtered.$$  
    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
    mv tmp.mnXC-Filtered.$$ "$of1"_mnXC-"$mnXCf"
    set of2 = "$of1"_mnXC-"$mnXCf"
    cat l.mnXCinfo
    cat -n $of2
    
  echo "Vest GRID-SEARCH one"
    set SWP = one  
    set of3 = dat.gp-search.Vest."$SWP"
    set vlpSPS = "10";  echo "km/sec"
    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
    set mnSEP = 10.0; echo "Travel Path differences of station-pairs w/ gp ORIGINAL"
    set mnSEP = 00.0; echo "Travel Path differences of station-pairs w/ gp USE"
    set mnX = -100.; set mxX = 100.; set dX =  5.
    set mnY = -100.; set mxY = 100.; set dY =  5.
    set mnD =   05.; set mxD =  35.; set dD =  5.
    /bin/rm $of3; touch $of3
    foreach oX (` echo $mnX $mxX $dX|gawk '{for(x=$1+0.;x<=$2+0.;x=x+$3+0.){printf("%.1f\n",x )}}' `)
    foreach oY (` echo $mnY $mxY $dY|gawk '{for(y=$1+0.;y<=$2+0.;y=y+$3+0.){printf("%.1f\n",y )}}' `)
    foreach oD (` echo $mnD $mxD $dD|gawk '{for(d=$1+0.;d<=$2+0.;d=d+$3+0.){printf("%.1f\n",d )}}' `)
    echo -n $oX $oY $oD":  " |tee -a $of3
    "$utl"/mVest.stats $of2 $oX $oY $oD $vlpSPS $Vflg $mnSEP |\
      "$utl"/mmed4 |tee -a $of3
    end
    end
    end
    set runtf = `date +%Y.%j,%T`
    set runtime = `caldate -f %H:%M:%S.%F -d -- $runtf $runt0`
    echo "RUNTIME:  $runtime"



#D  - SELECT viable gp's from Vest search one
#D    #IQR and Standard Error minimize:
#D      . Statitistics are of velocity estimates from program: _mVest.stats_ above.
#D      . For each gp, velocity estimates for station-pair combinations are made
#D      . Only reasonable estimates (i.e., between 2.5 and 3.75 km/s) are retained.
#D      . Summary order statistics of these reasonable estimates are determined.
#D      . SE is the standard error statistic of these velocity estimates, based on IQR.
#D      . Maximum SE cutoff is used as a criteria for gp_s with _stable_ velocity estimates
#D      SE=SD/sqrt(N-1)
#D      SD=IQR/1.35
#D     so,
#D      SE=(IQR/1.35)/sqrt(N-1)
#D     SELECTION FORMULA:
#D       . SE < mxSE (e.g., 0.20)
#D       . Minimum number of readings at least >= mnPAIR (e.g., 4) (very low needed for v. sparce data set)
#D       . Max of MXgp (e.g., 2000) gp's having largest number of readings
#D          = Larger number of readings indicates the gp is in a region where
#D            the travel-times to the most stations falls w/i an expected range
#D            (i.e., 2.5 to 3.75 km/s).
#D          = This is for a 41 x 41 x 7 == 11767 point grid)
#D          = Some situations will have significantly less than MXgp viable gp's
#D            (particularly if few recorded stations)
#D          = We initially need to examine a lot of gp possibilities because
#D            when scrounging the initial set of assumed reliable (XC based)
#D            stations may very well contain an outlier or two which will result
#D            is several possible regions of viable Vest's.  Outliers will be
#D            identified and excluded as part of the subsequent oT analysis.
#D  (OTPT:  dat.gp-select.Vest.one )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set SWP = one
    set if = dat.gp-search.Vest."$SWP"
    set mnPAIR = 4
    set mxSE = 0.20
    set MXgp = 2000
    gawk 'BEGIN{\
      mnpair=sprintf("%d","'"$mnPAIR"'"+0 );\
      mxse=sprintf("%f","'"$mxSE"'"+0. );\
    }{\
      N=sprintf("%f", $5+0. );\
      IQR=sprintf("%f", $17+0. );\
      if(N+0. >= mnpair+0.){\
        SE=sprintf("%f", (IQR/1.35)/(sqrt(N-1))+0. );\
        if(SE+0. < mxse+0.){\
          print $0,SE ;\
        }\
      }\
    }' $if |\
    sort -k 5,5n |tail -"$MXgp" |tee dat.gp-select.Vest."$SWP"
    set nn = `wc dat.gp-select.Vest."$SWP" |gawk '{print $1}'`

    # Z0_STOP TEST
    if ( "$nn" == "0" ) then
  echo "Z_STOP.  No data left in: dat.gp-select.Vest."$SWP". Processing aborted for: "$NVTID"" > Z0_STOP_"$NVTID"
      continue
    endif


echo "B1111"


#DS = FOR TESTING: Single REFINED grid-point
#D  [ set SWP = five
#D    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
#D    set if1 = dat.grid.search.sweep."$SWP"_RELIABLE.DDV
#D    set if3 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_RELIABLE
#D    set if3 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-"$mnXCf"
#D    set vlpSPS = "10";  echo "km/sec"
#D    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
#D    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
#D    set mnSEP = 00.0; echo "Travel Path differences of station-pairs w/ gp USE"
#D    set oX = ` gawk '{printf("%f", ($1+0.) )}' $if1 `
#D    set oY = ` gawk '{printf("%f", ($2+0.) )}' $if1 `
#D    set oD = ` gawk '{printf("%f", ($3+0.) )}' $if1 `
#D    echo     $oX $oY $oD":  ";\
#D    "$utl"/mVest.stats $of2 $oX $oY $oD $vlpSPS $Vflg $mnSEP |\
#D       sort -k 1,1n |cat -n
#D    ]]]
#DE = FOR TESTING: Single REFINED grid-point


#D    - OT grid-search one
#D     . 150609: Definitely not perfect but best I could come
#D         up with w/o killing myself.
#D     . 150611: Seems to be workable
#D     . 150701: Implemented here to only work on gp's that pass the
#D               Vest grid-search above
#D     . at_si == tt_si + ot
#D     . at_si == delX/vel + ot
#D     . at_si == (Xi-Xo)/vel
#D     . ot == at_si - (Xi-Xo)/vel, where
#D        Xo is (cLT,ClN,25km) and vel is some reasonable half-space velocity 
#D     = First lets get an idea of a good vel from high XC for good case
#D       + Do this by minimizing computing ot estimates for high XC stations
#D          where, ot = at_si - (Xi-Xo)/vel
#D          and, assuming source is at cLT, cLN and 25 km depth.
#D    S==OBVIATED by Vest processing
#D     + RE: velocity model:
#D       + SIMPLE half space:
#D         = in BWR velocity is treated as a gradient layer over a half space, I.E.:
#D           S 2.6444 0.05968 5.0316 40.0, where:
#D           . 2.6444 is S-phase surf_vel 
#D           . 0.05968 is gradient down to 40.0 km 
#D           . 5.0316 is half-space velocity below 40.0 km.
#D             [ echo "2.644 0.05968 40.0"|gawk '{print $1+($2*$3)}'
#D           . Simplifying assumptions:
#D              _ most tremors sources are 15 to 35 km depth (average 25 km).
#D              _ Average velocity is at ~ 1/2 source depth (i.e., 12.5 km)
#D              _ So [ echo "2.644 0.05968 12.5"|gawk '{print $1+($2*$3)}'
#D                ~ 3.4 km/sec is approximation to be used.
#D       + DEPTH DEPENDENT VELOCITY (DDV) (gradient) half space:
#D         = in BWR velocity is treated as a gradient layer over a half space, I.E.:
#D           S 2.6444 0.05968 5.0316 40.0, where:
#D           . 2.644 is S-phase surf_vel 
#D           . 0.05968 is gradient down to 40.0 km 
#D           . 5.0316 is half-space velocity below 40.0 km.
#D           . Simplifying assumptions:
#D              _ Assuming g-p depth is tremor source depth and ...
#D              _ the average travel-path velocity is the velocity at ~ 1/2 source depth then ...
#D              _ for the g-p use velocity ==  (e.g. for 25. km depth)
#D              [ set gpD = 25.0
#D                echo "2.644 0.05968 $gpD" |gawk '{printf("%.2f\n", $1+($2*((0.5)*$3)) ) }'
#D                ]]]
#D                E.G. for gpD == 25 km, MOD_VEL ~= 3.39 km/sec 
#D         = Turns out it will still be necessary for 'SWP one' to give a max MOD_VEL 
#D             in order to prevent station-GAP wander (trying 3.25 max).
#D    E==OBVIATED by Vest processing
#D
#D
#D  - W/ mnXC-FILTER option
#D  (OTPT: dat.gp-search.OT.one )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set runt0 = `date +%Y.%j,%T`
    set SWP = one
    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
    set if1 = dat.gp-select.Vest."$SWP"
    set if2 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-"$mnXCf"
    set of  = dat.gp-search.OT."$SWP"
    set vlpSPS = "10";  echo "km/sec"
    set mxNit = 15; echo "Maximum of iterations to deal with oscillations"
    set Mfs = 1.5; echo "Multiplication factor of fs for outlier determination"
    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
    /bin/rm $of; touch $of 
  echo "Loop over grid-points"
    cat $if1 |sed 's/\:/ /g' |\
      gawk '{\
        printf("%.1f_%.1f_%.1f_%f\n",$1,$2,$3,$11 );\
      }' > tmp.gps-xydv.$$
    foreach lst (` cat tmp.gps-xydv.$$ `)
      set oX = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $1 )}' `
      set oY = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $2 )}' `
      set oD = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $3 )}' `
      set oV = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%f", $4 )}' `
      set Nit = "0"
      set mnOT = -999.9
      set mxOT =  999.9
      echo $mnOT $mxOT
      set str0 = \
        `"$utl"/mGRIDsearch.v3 $if2 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Mfs $Vflg`
      set Ndat0 = `echo $str0 |gawk '{printf("%d",$8 )}'`
      set Nit = `echo "$Nit" |gawk '{printf("%d",$1+1)}'`
      if ( $Ndat0 < 7 ) then
        echo "___ WARNING: TO FEW DATA POINTS ($Ndat0 < 7), at: ___"
        echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
        echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
        echo "___ GRID-POINT NOT ESTIMATED___"
        continue
      endif
      if ( $Ndat0 == 7 ) then
        echo "___ WARNING: DATA POINTS == 7 at: ___"
        echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
        echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
        echo "___ GRID-POINT ESTIMATION STOPPED and OUTPUT___"
        echo $str0 $Nit |tee -a $of 
        continue
      endif

  echo "Iterative outlier removal"
      set alreadyprinted = "N"
      while ( $Ndat0 > 7 )
        set mnOT = `echo $str0 |gawk '{print $4}'`
        set mxOT = `echo $str0 |gawk '{print $5}'`
        set str2 = \
          `"$utl"/mGRIDsearch.v3 $if2 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Mfs $Vflg`
        set Ndat2 = `echo $str2 |gawk '{printf("%d",$8 )}'`
        set Nit = `echo "$Nit" |gawk '{printf("%d",$1+1)}'`
        if ( $Ndat2 < 7 ) then
          echo "___ WARNING: TO FEW DATA POINTS ($Ndat2 < 7), at later iteration: ___"
          echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
          echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
          echo "___ OUTPUTTING PREVIOUS ITERATION GRID-POINT ESTIMATE___"
          echo $str0 $Nit |tee -a $of 
          set alreadyprinted = "Y"
          break
        else if ( $Ndat2 == 7 ) then
          echo "___ WARNING: DATA POINTS == 7 at later iteration ___"
          echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
          echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          echo $str2 $Nit |tee -a $of 
          set alreadyprinted = "Y"
          break
        else if ( "$Ndat2" == "$Ndat0" ) then
          echo "___ IDENTICAL RESULTS TO PREVIOUS ITERATION ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          break
        else if ( "$Nit" >= "$mxNit" ) then
          echo "___ MAXIMUM ALLOWED ITERATIONS (mnNit) REACHED ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          break
        else 
          set str0 = "$str2"
          set Ndat0 = "$Ndat2"
        endif
      end
      if ( $alreadyprinted == "N" ) then
         echo $str0 $Nit |tee -a $of
      endif
      set alreadyprinted = "N"
    end
    echo "Vel: $oV   mnXCf: $mnXCf"
    set runtf = `date +%Y.%j,%T`
    set runtime = `caldate -f %H:%M:%S.%F -d -- $runtf $runt0`
    echo "RUNTIME:  $runtime"



#D     -------------------------------------------------------------------------------
#D     + GRID-POINT SELECTION: IQR-Nit TRADE-OFF (aka): Evaluation tests w/ iterations
#D     -------------------------------------------------------------------------------
#D S=== OBSOLETE
#D       . Small Nit indicates that the process of finding
#D           a final set of data converged more rapidly.
#D           - This implies: 
#D               + a more distinct separation between good data and outliers
#D               + and a more stable/reliable solution.
#D               ==> However, small Nit can also arise in cases where there are 
#D                   simply few data.
#D       . Large Nit can indicate that the process of finding
#D           a final set of data was either:
#D            1) Oscillating (Nit == mxNit == 15)
#D            2) Took a long time to converge, indicating:
#D               + a less distinct separation between good data and outliers.
#D               + and a less stable/reliable solution.
#D                ==> However, this can include cases where there is more
#D                 data that had to be sorted through.
#D       . There is also some tradeoff between IQR and Nit.
#D           - For a fixed set of data, increasing Nit tends
#D               reduce the number of stations and decrease the
#D               range of IQR. 
#D           - While decreasing the IQR is desirable, decreasing
#D               the number of stations if the removed stations
#D               are contributing reasonably good data.
#D               ==> This is because to few stations increases
#D               the possibility of grid-points outside the true
#D               source region giving viable false source locations.
#D       = HERE: Is an adaptive (iterative) method that optimizes
#D           the trade-off bewteen Nit and IQR to give more stable and reasonable 
#D           estimates of grid-point source locations.
#D           (I.E., IQR-Nit TRADE-OFF SOLUTION )
#D            1. Start with cutNit == 1
#D            2.  Evaluate data
#D            3.  WHILE [ *INSUFFICIENT DATA || *med{IQR} > cutIQR (~2.8(arbitrary tests)) ] 
#D                  cutNit = cutNit +1
#D                  Evaluate data
#D                END
#D                * Sufficient data is when 'cutNdat' or more grid points remain
#D                    after mn,mxIQR, cutNit, and mnNstn filtering
#D                * med{IQR} is the median IQR of the 'cutNit' grid point values
#D            4.  IF [ SUFFICIENT DATA && med{IQR} < cutIQR (~2.8(arbitrary tests)) ] 
#D                  Evaluate data
#D                  OUTPUT stable/reasonable estimate of grid-point source location
#D                END
#D     (OTPT: dat.gp-select.OT.one )
#D       cd $datDIR
#D       cd DAT_"$NVTID"
#D       cd DAT.TRMD
#D
#D       set SWP = one
#D       set if = dat.gp-search.OT."$SWP"
#D       set of = dat.gp-select.OT."$SWP"
#D
#D       set mnNstn = "7"
#D       set cutNit = "1"; echo "starting Nit value"
#D
#D        # NO_org
#D       set mnIQR = 0.0; set mxIQR = 3.5; echo "ORG150711"
#D       set cutIQR = "2.8"; echo "ORG150711"
#D       set cutNdat = "27"; echo "(9 gp's per layer x 3 layers of surrounding gp's :: PRIOR)"
#D       set cutNdat2 = `echo $cutNdat |gawk '{printf("%d",$1/2)}'`
#D
#D        #NO_2
#D       set mnIQR = 0.0; set mxIQR = 4.0; echo "ORG150718"
#D       set cutIQR = "3.5"; echo "ORG140718"
#D       set cutNdat = "81"; echo "(25 gp's per layer x 5 layers of surrounding gp's :: USE)"
#D       set cutNdat2 = `echo $cutNdat |gawk '{printf("%d",$1/3)}'`
#D
#D        #NO_3
#D       set mnIQR = 0.0; set mxIQR = 4.0; echo "ORG150718"
#D       set cutIQR = "3.5"; echo "ORG140718"
#D       set cutNdat = "123"; echo "(25 gp's per layer x 5 layers of surrounding gp's :: USE)"
#D       set cutNdat2 = `echo $cutNdat |gawk '{printf("%d",$1/2)}'`
#D
#D        #4 USE:
#D       set mnIQR = 0.0; set mxIQR = 3.5; echo "ORG150718"
#D       set cutIQR = "3.2"; echo "ORG140718"
#D       set cutNdat = "123"; echo "(25 gp's per layer x 5 layers of surrounding gp's :: USE)"
#D       set cutNdat2 = `echo $cutNdat |gawk '{printf("%d",$1/2)}'`
#D
#D       "$utl"/m.nit-iqr-trade.v4 $utl $mnIQR $mxIQR $mnNstn \
#D                              $cutIQR $cutNit $cutNdat $cutNdat2 $if  |tee $of
#D E=== OBSOLETE


#D     REVISED  IQR-Nit  TRADE-OFF  (aka. m.nit...)
#D     RATIONALE: 
#D     Fundamentally, the idea is that we want a gp estimate of location from OT search data.  
#D     To make gp selection more robust, Median station values from a range of candidate grid points are used.
#D       .Each line of the OT data contains summary statistics of the estimates of OT among stations for 
#D          an NVT source relative to the ERM-template, computed for the usable stations.
#D       .For each gp, 
#D          The OTs for all stations w/ high enough XC are first computed. 
#D          Then outliers are iteratively removed, using iterations of a box-plot based apporach.
#D          Then standard order-statistics are calculated.
#D       .Statistics include:
#D          - nSTN left after outlier removal
#D          - MED and IQR of station estimate OTs 
#D          - NIT == Number of iterations required to remove ouliers
#D       .An additional parameter is the number of candidate gp's to be considered.
#D          Selection of a single BEST gp is not always viable due to occasional/spurious statistics.
#D          However, usually a range of gp's give similar results.
#D          Hence, we make a final gp selection based on statistics from a range of gp results.
#D          Ocassionally, there are multiple, statisticaly similar gp families (multi-mode groups).
#D          Typically the mult-mode families are comprised of close-in (shorter TTs) and remote types.
#D          The remote types result primarily from lack of azimuthal control.
#D          So, we preferentially select the close-in (shorter TTs == later OT) modes.
#D  
#D       Theoretically OT is an INVARIANT quauntity for an NVT (i.e., its origin time).
#D       Simplifying assumptions and measurement error cause estimates of the OTs from
#D         different stations to behave statistically (i.e., distribute themselves about a central value).
#D       The dispersion and outlier characteristics of these statistics for a given gp
#D         provide information on how viable the gp is as a potential source location.
#D       If there are lots of outliers and/or dispersion is large, then the gp is a poor
#D         candidate for representing the NVT source.
#D       If there are few outliers and dispersion is small, then the gp is a good candiate:
#D       For a gp, if many iterations of outlier removal were needed (i.e., large NIT),
#D         then the gp is considered unstable because arrival-times from a source at 
#D         the gp fit poorly to the body of arrival-time data. 
#D       Likewise, a larger dispersion in OT estimates among stations at a gp 
#D         (i.e, IQR about an average OT) also indications a poor fit.
#D       It is also observed that if very few stations are used (e.g, nSTN < 12) 
#D         results are poorly constrained and results can be erroneous.
#D       We also observe that both the IQR and the NIT (needed for outlier removal) 
#D         often depend on how much data (i.e., nSTNs) are used in the analysis).
#D       For IQR, the nSTNs can be partially compensated for by using IQR-->SD-->SE.
#D       The NIT case is more challenging. 
#D       For a gp: an NIT == 2 means no outliers remove after applying box-plot filter 1st time.
#D                 an NIT == 3 means some outliers removed after filter 1st time but no more 2nd time.
#D                 an NIT == 4 means some outliers removed after 2nd time filting but none after 3rd time
#D       Often after outliers are removed during a filter cycle (NIT), the MED and IQR shift. 
#D       The box-plot filter methodology, uses the MED and IQR to determine filter bounds.
#D       Therefore, the bounds get adjusted for the next NIT cycle, if outliers have been removed. 
#D       When no more outliers are removed between NIT cycles, the solution is considered complete.
#D       IF it took a lot of cycles to complete for a gp, then the station OTs estimates are poorly constrained.
#D       That means that expected travel-times (TT) from that gp to not match the observed 
#D         arrival-time (AT) data very well and the gp is a poor candidate for a source location.
#D       However, sometimes the starting set of station ATs has a few spurious measurements, so
#D         it is not uncommon, (esp. for large nSTNs) for a cycle or two of box-plot filtering to 
#D         be required to remove the spurious measurement and a stable solution to result for a gp.
#D       THEREFORE, MAXNIT == 4 (NIT<= 4; stable solution after 2 filter cycles) seems a reasonable
#D         criteria for selection.  Observations from test cases hold this to be true and that larger
#D         MAXNIT start to include spurious/unstable gps. So NITs >= 5 will be ignored.
#D       Also for gp w/ particularly large IQR values (very broad dispersion) tend to give erroneous
#D         results.  
#D       Here the IQR is very large and the box-plot bounds very loose.  
#D       So outliers are not recognized and not removed.
#D       Caution is needed however, since somewhat larger IQRs also occur when the gp is close-in to a 
#D         concentration of tightly spaced stations (e.g., the HRSN set).
#D       THEREFORE, a mxIQR == (TBD) filter will be include to remove particularly large IQR values.
#D          
#D       Consider two end-members:
#D           1) Few nSTNs
#D               - LOW NIT gp's 
#D                 . Indicates fewer outliers, or that outliers are not reconizable due to few 
#D                     cconstraining data
#D                 . Keeps gp's with more station data for optimizing constraint on results.
#D                 . BUT, sometimes leads to unrecognized spurious station data, leading to 
#D                     severely skewed and inaccurate results.
#D               - HIGH NIT gp's
#D                 . Implies more outliers and/or an unstable gp. 
#D                 . REMOVES spurious station data, generally, reducing chance of skewed results.
#D                 . HOWEVER potential for low nSTNs and poorly constrained and inaccurate results
#D               = These problems are unavoidable consequences of sparce data and the 
#D                   best (least undesirable) solution is to choose parameters that 
#D                   minimze circumstances leading to erroneous results. 
#D                 . An example is case is:   DAT_2015.076,13:25:26.0000   (no vlp filtering) 
#D                    where the starting number of stations is 13 and one of them is spurious
#D                 . Best solution I could come up with is to deal with this end member: 
#D                     a) start with NIT <= a HIGH value (maxNIT == 4)
#D                     b) iterate NIT down until you get >= 27 gp's with at least 12 stations
#D                        (or whatevers is left if NIT == 2 and < 27 gp's)
#D                     c) select among these gp's the gp's with the lowest seINT 
#D                        (to remove gp's solutions having suspect station data)
#D                        and among those, those 27 with the shortest OTest's (MEDIAN OT estimates).
#D                        (to address the multi-mode problem).
#D           1) Many nstns
#D               - LOW NIT gp's 
#D                 . Indicates few outliers 
#D                 . Keeps gp's with more station data for generally better constraint on results.
#D                 . However w/ many stations, very low NIT's (e.g., == 2 or even 3) do not allow 
#D                    for sufficient removal of spurious station data in computing gp stats.
#D                 . Also restricting to low NIT's sometimes excludes too many good gp's from
#D                    consideration at gp-locations and NO solution is obtained! 
#D               - HIGH NIT gps
#D                 . REMOVES spurious station data, generally, reducing chance of skewed results.
#D                 . HOWEVER Implies unstable gp locations where OT expectations for the gp 
#D                     are not fit by a significant portion of the station data.
#D                 . When considering gp's having NIT <= MAXNIT, observations indicate that when:
#D                     + MAXNIT == 2 Some NVTs are exluded entirely (i.e., every gp had at least cycle of
#D                                   outlier removal carried out, this can happen when the is a bad stantion)
#D                     + MAXNIT == 3 Viable but occasional modestly suspect results
#D                                (i.e., 2014.299,03:04:38.5000 w/ no vlp filtering)
#D                     + MAXNIT == 4 Viable with modestly less suspect results.
#D                                (i.e., 2014.299,03:04:38.5000 w/ no vlp filtering)
#D                                (i.e., 2015.085,19:17:25.0000 w/ no vlp filtering)
#D                                (i.e., 2015.081,03:30:24.0000 w/ no vlp filtering)
#D                     + MAXNIT >= 5 typically results in erroneous results
#D               -  
#D             Basically, when NIT goes up, nstns used goes down
#D                even approximately stable results require nstns ~ 10 for stable solution 
#D             So There is information on:
#D                        OTs (for multi-mode control)
#D                        Nstns used (for constrain
#D                        scatter/dispersion (IQR) 
#D                        outliers (NIT)
#D       So, PLAN for happy medium:
#D          1. Set mnSTN = 12;   mnREC=27; mxIQR==4.;  MAXNIT=4, (smallest NIT is 2 by default).
#D          2. Compute SE and integer value of SE (seINT) for sorting.
#D          3. Compute integer value of OT (otINT) for sorting. 
#D          4. Save gp records with <= MAXNIT && IQR <= mxIQR
#D          5. Among data from step 4, count and save separately those records with >= mnSTN
#D          6. IF number of records of records from step 5 is >= mnREC, 
#D               sort otINT(larges-negative to lowest-negative(bottom)), nstns(low to high(bottom), 
#D                    and seINT (highest to lowest(bottom))  
#D               keep last mnREC records
#D               Compute statistical gp location inforation
#D               Save result
#D               exit
#D          7. If number of records < mnREC && NIT != 2,
#D               decrement NIT and repeat from step 4.
#D          8. If number of records < mnREC && NIT == 2 (ie., the minimum possible)
#D               sort otINT(larges-negative to lowest-negative(bottom)), nstns(low to high(bottom), 
#D                    and seINT (highest to lowest(bottom))  
#D               keep all records
#D               Compute statistical gp location inforation
#D               Save result
#D               exit
#D
#D     (OTPT: dat.gp-select.OT.one )
       cd $datDIR
       cd DAT_"$NVTID"
       cd DAT.TRMD
       set SWP = one
       set if = dat.gp-search.OT."$SWP"
       set of = dat.gp-select.OT."$SWP"

       set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
       set mnSTN = 12;# echo "USE, 150722 minimum number of stations ELSE lower NIT"
       set mnREC = 27;# echo "USE, 150722 minumum number of gp-records ELSE lower NIT" 
       set mxIQR = 3.5;# echo "USE, 150722"
       set MAXNIT = 2;# echo "DEFINITE NO, SOME NVTs always have a bad station that must be removed"
       set MAXNIT = 3;# echo "Occasionally, modestly more suspect results"
       set MAXNIT = 4;# echo "USE, 150722: maximum NIT value allowed.  Higher usually means poor convergence"
       cat $if |\
       gawk 'BEGIN{\
         minstn=sprintf("%d","'"$mnSTN"'"+0 );\
         minrec=sprintf("%d","'"$mnREC"'"+0 );\
         mxiqr=sprintf("%f","'"$mxIQR"'"+0. );\
         MAXNIT=sprintf("%d","'"$MAXNIT"'"+0 );\
         i=0+0;\
       }{\
         i=i+1;\
         nstn=sprintf("%d",$8+0);\
         iqr=sprintf("%f",$20+0.);\
         SE=sprintf("%f",(iqr/1.35)/sqrt(nstn-1) );\
         seINT=sprintf("%f",int((10*SE)+0.5)+0 );\
         otINT=sprintf("%f",int($14-0.5)+0 );\
         lin[i]=sprintf("%s %f %d %d\n", $0,SE,seINT,otINT );\
       }END{\
         NIT=MAXNIT+0;\
         while(NIT+0 >= 2+0){\
           nrec=nraw=0+0;\
           for(j=1;j<=i;j++){\
             split(lin[j],a);\
             iqr=a[20]+0.;\
             nit=a[21]+0;\
             nsta=a[8]+0;\
             if(nit+0 <= NIT+0 && iqr+0. <= mxiqr+0.){\
               nraw=nraw+1;\
               otptraw[nraw]=lin[j];\
               if(nsta+0 >= minstn+0 ){\
                 nrec=nrec+1;\
                 otpt[nrec]=lin[j];\
               }\
             }\
           }\
           if(nrec+0 >= minrec+0){\
             for(k=1;k<=nrec;k++){\
               printf("%s", otpt[k] );\
             }\
             exit;\
           }\
           if(NIT+0 == 2+0){\
             for(k=1;k<=nraw;k++){\
               printf("%s", otptraw[k] );\
             }\
             exit;\
           }\
           NIT=NIT-1;\
         }\
       }' |\
           sort -k24,24n -k8,8n -k23,23nr  | tail -"$mnREC" > tmpx.$$

       echo "Data Used:" > $of
       cat tmpx.$$ >> $of
       set nSTRT = ` wc l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-"$mnXCf" |gawk '{printf("%d",$1+0.)}' `
       set Sstats  = ` gawk '{print $8}'  tmpx.$$ |"$utl"/mmed4 `
       set OTstats = ` gawk '{print $14}'  tmpx.$$ |"$utl"/mmed4 `
       set Xstats  = ` gawk '{print $1}'  tmpx.$$ |"$utl"/mmed4 `
       set Ystats  = ` gawk '{print $2}'  tmpx.$$ |"$utl"/mmed4 `
       set Dstats  = ` gawk '{print $3}'  tmpx.$$ |"$utl"/mmed4 `
       set Vstats  = ` gawk '{print $6}'  tmpx.$$ |"$utl"/mmed4 `
       echo >> $of
       echo "$Sstats"  |gawk '{printf("mmSTN:  STRT: %" "2d  %s\n","'"$nSTRT"'"+0, $0 )}' >> $of
       echo "$OTstats" |gawk '{print "mmOT:            ",$0}' >> $of
       echo >> $of
       echo "$Xstats"  |gawk '{print "mmX:             ",$0}' >> $of
       echo "$Ystats"  |gawk '{print "mmY:             ",$0}' >> $of
       echo "$Dstats"  |gawk '{print "mmD:             ",$0}' >> $of
       echo "$Vstats"  |gawk '{print "mmV:             ",$0}' >> $of
       echo >> $of
       cat $of


#Techo "SUMMARY:  $NVTID"
#T       set S = ` echo $STNstats |gawk '{print $11}' `
#T       set X = ` echo $Xstats |gawk '{print $9}' `
#T       set Xiqr = ` echo $Xstats |gawk '{print $15}' `
#T       set Y = ` echo $Ystats |gawk '{print $9}' `
#T       set Yiqr = ` echo $Ystats |gawk '{print $15}' `
#T       set D = ` echo $Dstats |gawk '{print $9}' `
#T       set Diqr = ` echo $Dstats |gawk '{print $15}' `
#T       set V = ` echo $Vstats |gawk '{print $9}' `
#T       set Viqr = ` echo $Vstats |gawk '{print $15}' `
#T       echo "$NVTID  $X $Y $D $V" $Xiqr $Yiqr $Diqr $Viqr|\
#T         gawk '{printf("%s  %" "4.1f %" "4.1f %" "4.1f %" "5.2f   %" "5.2f %" "5.2f %" "5.2f %" "6.3f\n",\
#T           $1,$2,$3,$4,$5,$6,$7,$8,$9 )}'


echo "B2222"


#D   -------------------------------------------------------------------------------
#D   + FOUND initial GRID-POINT now REFINE
#D   -------------------------------------------------------------------------------
#D  - Vest grid-search two
#D    . Vest for REFINE/REDUCED ZONE 
#D  (OTPT: dat.gp-search.Vest.two )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set runt0 = `date +%Y.%j,%T`
    set SWP = two  
    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
    set if1 = dat.gp-select.OT.one
    set if2 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-"$mnXCf"
    set of = dat.gp-search.Vest."$SWP"
  mv $of "$of".org
    set vlpSPS = "10";  echo "km/sec"
    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
    set mnSEP = 00.0; echo "Travel Path differences of station-pairs w/ gp USE"
  echo "Vest GRID-SEARCH"
    set mnX = `egrep '^mmX\: ' $if1 |gawk '{printf("%f", ($9-24.) )}'`
    set mxX = `egrep '^mmX\: ' $if1 |gawk '{printf("%f", ($9+24.) )}'`
    set dX = 2.
    set mnY = `egrep '^mmY\: ' $if1 |gawk '{printf("%f", ($9-24.) )}'`
    set mxY = `egrep '^mmY\: ' $if1 |gawk '{printf("%f", ($9+24.) )}'`
    set dY = 2.
    set mnD =  4.; 
    set mxD = 36.; 
    set dD =  2.
    /bin/rm $of; touch $of
    foreach oX (` echo $mnX $mxX $dX|gawk '{for(x=$1+0.;x<=$2+0.;x=x+$3+0.){printf("%.1f\n",x )}}' `)
    foreach oY (` echo $mnY $mxY $dY|gawk '{for(y=$1+0.;y<=$2+0.;y=y+$3+0.){printf("%.1f\n",y )}}' `)
    foreach oD (` echo $mnD $mxD $dD|gawk '{for(d=$1+0.;d<=$2+0.;d=d+$3+0.){printf("%.1f\n",d )}}' `)
      echo -n $oX $oY $oD":  " |tee -a $of
      "$utl"/mVest.stats $if2 $oX $oY $oD $vlpSPS $Vflg $mnSEP |\
        "$utl"/mmed4 |tee -a $of
    end
    end
    end
    set runtf = `date +%Y.%j,%T`
    set runtime = `caldate -f %H:%M:%S.%F -d -- $runtf $runt0`
    echo "RUNTIME:  $runtime"


#D  + SELECT viable gp's from Vest search two
#D    #IQR and Standard Error minimize:
#D      SE=SD/sqrt(N-1)
#D      SD=IQR/1.35
#D     so,
#D      SE=(IQR/1.35)/sqrt(N-1)
#D     SELECTION FORMULA:
#D       . SE < mxSE (e.g., 0.20)
#D       . Minimum number of readings at least >= mnPAIR (e.g., 4) (very low needed for v. sparce data set)
#D       . Max of MXgp (e.g., 1500 for SWP two) gp's having largest number of readings
#D          = Larger number of readings indicates the gp is in a region where
#D            the travel-times to the most stations falls w/i an expected range
#D            (i.e., 2.5 to 4.0 km/s).
#D          = This is for a 41 x 41 x 7 == 11767 point grid)
#D          = Some situations will have significantly less than MXgp viable gp's
#D            (particularly if few recorded stations)
#D          = We initially need to examine a lot of gp possibilities because
#D            when scrounging the initial set of assumed reliable (XC based)
#D            stations may very well contain an outlier or two which will result
#D            is several possible regions of viable Vest's.  Outliers will be
#D            identified and excluded as part of the subsequent oT analysis.
#D  (OTPT:  dat.gp-select.Vest.two )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set SWP = two
  mv dat.gp-select.Vest."$SWP" dat.gp-select.Vest."$SWP".org
    set if = dat.gp-search.Vest."$SWP"
    set mnPAIR = 4
    set mxSE = 0.20
    set MXgp = 1500
    gawk 'BEGIN{\
      mnpair=sprintf("%d","'"$mnPAIR"'"+0 );\
      mxse=sprintf("%f","'"$mxSE"'"+0. );\
    }{\
      N=sprintf("%f", $5+0. );\
      IQR=sprintf("%f", $17+0. );\
      if(N+0. >= mnpair+0.){\
        SE=sprintf("%f", (IQR/1.35)/(sqrt(N-1))+0. );\
        if(SE+0. < mxse+0.){\
          print $0,SE ;\
        }\
      }\
    }' $if |\
    sort -k 5,5n |tail -"$MXgp" |tee dat.gp-select.Vest."$SWP"


#D  - OT grid-search two
#D  (OTPT: dat.gp-search.OT.two )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set runt0 = `date +%Y.%j,%T`
    set SWP = two
    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
    set if1 = dat.gp-select.Vest."$SWP"
    set if2 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-"$mnXCf"
    set of  = dat.gp-search.OT."$SWP"
  mv $of "$of".org
    set vlpSPS = "10";  echo "km/sec"
    set mxNit = 15; echo "Maximum of iterations to deal with oscillations"
    set Mfs = 1.5; echo "Multiplication factor of fs for outlier determination"
    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
    /bin/rm $of; touch $of 
  echo "Loop over grid-points"
    cat $if1 |sed 's/\:/ /g' |\
      gawk '{\
        printf("%.1f_%.1f_%.1f_%f\n",$1,$2,$3,$11 );\
      }' > tmp.gps-xydv.$$
    foreach lst (` cat tmp.gps-xydv.$$ `)
      set oX = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $1 )}' `
      set oY = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $2 )}' `
      set oD = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $3 )}' `
      set oV = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%f", $4 )}' `
      set Nit = "0"
      set mnOT = -999.9
      set mxOT =  999.9
      echo $mnOT $mxOT
      set str0 = \
        `"$utl"/mGRIDsearch.v3 $if2 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Mfs $Vflg`
      set Ndat0 = `echo $str0 |gawk '{printf("%d",$8 )}'`
      set Nit = `echo "$Nit" |gawk '{printf("%d",$1+1)}'`
      if ( $Ndat0 < 7 ) then
        echo "___ WARNING: TO FEW DATA POINTS ($Ndat0 < 7), at: ___"
        echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
        echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
        echo "___ GRID-POINT NOT ESTIMATED___"
        continue
      endif
      if ( $Ndat0 == 7 ) then
        echo "___ WARNING: DATA POINTS == 7 at: ___"
        echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
        echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
        echo "___ GRID-POINT ESTIMATION STOPPED and OUTPUT___"
        echo $str0 $Nit |tee -a $of 
        continue
      endif

  echo "Iterative outlier removal"
      set alreadyprinted = "N"
      while ( $Ndat0 > 7 )
        set mnOT = `echo $str0 |gawk '{print $4}'`
        set mxOT = `echo $str0 |gawk '{print $5}'`
        set str2 = \
          `"$utl"/mGRIDsearch.v3 $if2 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Mfs $Vflg`
        set Ndat2 = `echo $str2 |gawk '{printf("%d",$8 )}'`
        set Nit = `echo "$Nit" |gawk '{printf("%d",$1+1)}'`
        if ( $Ndat2 < 7 ) then
          echo "___ WARNING: TO FEW DATA POINTS ($Ndat2 < 7), at later iteration: ___"
          echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
          echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
          echo "___ OUTPUTTING PREVIOUS ITERATION GRID-POINT ESTIMATE___"
          echo $str0 $Nit |tee -a $of 
          set alreadyprinted = "Y"
          break
        else if ( $Ndat2 == 7 ) then
          echo "___ WARNING: DATA POINTS == 7 at later iteration ___"
          echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
          echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          echo $str2 $Nit |tee -a $of 
          set alreadyprinted = "Y"
          break
        else if ( "$Ndat2" == "$Ndat0" ) then
          echo "___ IDENTICAL RESULTS TO PREVIOUS ITERATION ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          break
        else if ( "$Nit" >= "$mxNit" ) then
          echo "___ MAXIMUM ALLOWED ITERATIONS (mnNit) REACHED ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          break
        else 
          set str0 = "$str2"
          set Ndat0 = "$Ndat2"
        endif
      end
      if ( $alreadyprinted == "N" ) then
         echo $str0 $Nit |tee -a $of 
      endif
      set alreadyprinted = "N"
    end
    echo "Vel: $oV   mnXCf: $mnXCf"
    set runtf = `date +%Y.%j,%T`
    set runtime = `caldate -f %H:%M:%S.%F -d -- $runtf $runt0`
    echo "RUNTIME:  $runtime"


#D     -------------------------------------------------------------------------------
#D     + REFINED GRID-POINT SELECTION: IQR-Nit TRADE-OFF (aka): Evaluation tests w/ iterations
#D     -------------------------------------------------------------------------------
#D E=== OBSOLETE
#D     (OTPT: dat.gp-select.OT.two )
#D       cd $datDIR
#D       cd DAT_"$NVTID"
#D       cd DAT.TRMD
#D
#D       set SWP = two
#D       set if = dat.gp-search.OT."$SWP"
#D       set of = dat.gp-select.OT."$SWP"
#D       set previf = dat.gp-select.OT.one
#D       set mnIQR = 0.0; set mxIQR = 3.5
#D       set cutIQR = "2.8"
#D
#D       set mnIQR = 0.0; set mxIQR = 4.0; echo "150718"
#D       set mnNstn = "7"
#D       set cutIQR = "3.5"; echo "150718"
#D       set cutNit = "1"; echo "starting Nit value"
#D
#D       set cutNdat = "27"; echo "USE"
#D       set cutNdat = "54"; echo "USE"
#D       set cutNdat = "81"; echo "USE"
#D       set cutNdat = "125"; echo "(25 gp's per layer x 5 layers of surrounding gp's :: PRIOR)"
#D
#D       set cutNdat = "27"; echo "150718: ( 9 gp's per layer x 3 layers of surrounding gp's :: USE)"
#D       set cutNdat2 = `echo $cutNdat |gawk '{printf("%d",$1/2)}'`
#D
#D        #4 USE:
#D       set mnIQR = 0.0; set mxIQR = 3.5; echo "ORG150718"
#D       set cutIQR = "3.2"; echo "ORG140718"
#D       set cutNdat = "123"; echo "(25 gp's per layer x 5 layers of surrounding gp's :: USE)"
#D       set cutNdat2 = `echo $cutNdat |gawk '{printf("%d",$1/2)}'`
#D
#D       "$utl"/m.nit-iqr-trade.v4 $utl $mnIQR $mxIQR $mnNstn \
#D                              $cutIQR $cutNit $cutNdat $cutNdat2 $if  |tee $of
#D       echo; echo "pre-REFINED: "; tail -10 $previf
#D E=== OBSOLETE
#D
#D     REVISED  IQR-Nit  TRADE-OFF  stage two (aka. m.nit...)
#D     RATIONAL (see IQR-Nit TRADE-OFF for stage "one" above)
#D       So, PLAN for happy medium:
#D       CAUTION (150722 modifications made)
#D          1. Set mnSTN = 12;   mnREC=27; mxIQR==4.;  MAXNIT=4, (smallest NIT is 2 by default).
#D          2. Compute SE and integer value of SE (seINT) for sorting.
#D          3. Compute integer value of OT (otINT) for sorting. 
#D          4. Save gp records with <= MAXNIT && IQR <= mxIQR
#D          5. Among data from step 4, count and save separately those records with >= mnSTN
#D          6. IF number of records from step 5 is >= mnREC, 
#D               sort otINT(larges-negative to lowest-negative(bottom)), nstns(low to high(bottom), 
#D                    and seINT (highest to lowest(bottom))  
#D               keep last mnREC records
#D               Compute statistical gp location inforation
#D               Save result
#D               exit
#D          7. If number of records < mnREC && NIT != 2,
#D               decrement NIT and repeat from step 4.
#D          8. If number of records < mnREC && NIT == 2 (ie., the minimum possible)
#D               sort otINT(larges-negative to lowest-negative(bottom)), nstns(low to high(bottom), 
#D                    and seINT (highest to lowest(bottom))  
#D               keep all records
#D               Compute statistical gp location inforation
#D               Save result
#D               exit
#D          *NOTE: For stage "two", am trimming the v. low 25% of OTs (least neg.) since they bias 
#D                 the results to shallow depths.  More depth bias reduction planned for stage "three"
#D       PERSPECTIVE 150729:  
#d         Why do I need accurated gp_s?
#D         I need the range of associated OT estimates (Q1,Q3,IQR) to use in box-plot
#D           filtering for selection of other lower XC stations based on their OTs.  
#D         So at this point, getting reasonable depths is also important.
#D         Therefore adding means for estimating depths after lat-lons obtained.
#D
#D     (OTPT: dat.gp-select.OT.two )
       cd $datDIR
       cd DAT_"$NVTID"
       cd DAT.TRMD
       set SWP = two
       set if = dat.gp-search.OT."$SWP"
       set of = dat.gp-select.OT."$SWP"

       # Data to start with
       set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
       set mnSTN = 12;# echo "USE, 150722 same as stage "one"
       set mxIQR = 3.5;# echo "USE, 150722"
       set MAXNIT = 4;# echo "USE, 150722: maximum NIT value allowed.  Higher usually means poor convergence"
       set mnREC = 250;# echo "USE, 150722 greater number than stage "one" because denser gp's"
# If mnREC of 187, sorting on OT and keeping the first 125 OTs removes 50% of shortest TTs
       set mnREC = 187;# echo "..., 150722 greater number than stage "one" because denser gp's"
# If mnREC of 125, sorting on OT and keeping the first 125 OTs removes  0% of shortest TTs
       set mnREC = 125;# echo "..., 150722 greater number than stage "one" because denser gp's"
# Trial: Using mnREC of 155, sorting on OT and keeping the first 125 OTs removes 25% of shortest TTs
       set mnREC = 155;# echo "USE, 150722 greater number than stage "one" because denser gp's"
# USE: Using mnREC of 27, sorting on OT and keeping the first w1 then w2 OTs removes xx% of shortest TTs
       set mnREC = 27;# echo "USE, 150727 greater number than stage "one" because denser gp's"
       cat $if |\
       gawk 'BEGIN{\
         minstn=sprintf("%d","'"$mnSTN"'"+0 );\
         minrec=sprintf("%d","'"$mnREC"'"+0 );\
         mxiqr=sprintf("%f","'"$mxIQR"'"+0. );\
         MAXNIT=sprintf("%d","'"$MAXNIT"'"+0 );\
         i=0+0;\
       }{\
         i=i+1;\
         nstn=sprintf("%d",$8+0);\
         iqr=sprintf("%f",$20+0.);\
         SE=sprintf("%f",(iqr/1.35)/sqrt(nstn-1) );\
         seINT=sprintf("%f",int((10*SE)+0.5)+0 );\
         otINT=sprintf("%f",int($14-0.5)+0 );\
         lin[i]=sprintf("%s %f %d %d\n", $0,SE,seINT,otINT );\
       }END{\
         NIT=MAXNIT+0;\
         while(NIT+0 >= 2+0){\
           nrec=nraw=0+0;\
           for(j=1;j<=i;j++){\
             split(lin[j],a);\
             iqr=a[20]+0.;\
             nit=a[21]+0;\
             nsta=a[8]+0;\
             if(nit+0 <= NIT+0 && iqr+0. <= mxiqr+0.){\
               nraw=nraw+1;\
               otptraw[nraw]=lin[j];\
               if(nsta+0 >= minstn+0 ){\
                 nrec=nrec+1;\
                 otpt[nrec]=lin[j];\
               }\
             }\
           }\
           if(nrec+0 >= minrec+0){\
             for(k=1;k<=nrec;k++){\
               printf("%s", otpt[k] );\
             }\
             exit;\
           }\
           if(NIT+0 == 2+0){\
             for(k=1;k<=nraw;k++){\
               printf("%s", otptraw[k] );\
             }\
             exit;\
           }\
           NIT=NIT-1;\
         }\
       }' > tmp.A.$$
      
       # gp-location Stats (Best X,Y w/o depth control)
       set w1 = 625;#USE
       set w2 = 27;#USE
       #echo "w1== $w1"
       #echo "w2== $w2"
       sort -k22,22nr tmp.A.$$ |tail -"$w1" |\
       sort -k14,14n           |tail -"$w2"  |\
       gawk '{ lin[NR]=$0;\
       }END{\
         if( ((NR+0)%(2+0)) == 0+0 ){\
           for(i=1;i<NR;i++){\
             print lin[i];\
           }\
         }\
         if( ((NR+0)%(2+0)) == 1+0 ){\
           for(i=1;i<=NR;i++){\
             print lin[i];\
           }\
         }\
       }' > tmpx.$$
       set nSTRT = ` wc l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-"$mnXCf" |gawk '{printf("%d",$1+0.)}' `
       set Sstats  = ` gawk '{print $8}'  tmpx.$$ |"$utl"/mmed4 `
       set OTstats = ` gawk '{print $14}'  tmpx.$$ |"$utl"/mmed4 `
       set Xstats  = ` gawk '{print $1}'  tmpx.$$ |"$utl"/mmed4 `
       set Ystats  = ` gawk '{print $2}'  tmpx.$$ |"$utl"/mmed4 `
       set Dstats  = ` gawk '{print $3}'  tmpx.$$ |"$utl"/mmed4 `
       set Vstats  = ` gawk '{print $6}'  tmpx.$$ |"$utl"/mmed4 `

       # gp-location Stats with refined depths
       set X = ` echo $Xstats |gawk '{print $8}' `
       set Y = ` echo $Ystats |gawk '{print $8}' `
       gawk 'BEGIN{x=sprintf("%f","'"$X"'"+0.);y=sprintf("%f","'"$Y"'"+0.)}{\
         if(x-4. <= $1+0. && $1+0. <= x+4.){\
           if(y-4. <= $2+0. && $2+0. <= y+4.){\
             print $0;\
           }\
         }\
       }' tmp.A.$$ |sort -k 8,8n > tmp.B.$$                                  # gps w/i 4 km of Best X,Y loc.
       set lrgNstn = ` sed -n '$,$p' tmp.B.$$ |gawk '{print $8+0}' `
       gawk '{ if($8+0 >= "'"$lrgNstn"'"-1){print $0} }' tmp.B.$$ > tmp.C.$$ # Largest nSTNs
       set Nrec = ` wc tmp.C.$$ |gawk '{print $1}' `
       set Nkp = `echo $Nrec |gawk '{N=sprintf("%d",($1/2.) );if((N%2) == 0+0){N=N+1};print N+0}' `
       sort -k 14,14nr tmp.C.$$ |tail -"$Nkp" > tmp.D.$$                     # Earliest OTs w/i 4 km of Best
       set nwDstats = ` gawk '{print $3+0.}'  tmp.D.$$ |"$utl"/mmed4 `

       # Output
       echo "Data Used for X,Y control:" > $of
       cat tmpx.$$ >> $of
       echo >> $of
       echo "Data Used for D control:"  >> $of
       cat tmp.D.$$ >> $of
       echo >> $of
       echo "NVTID:  $NVTID" >> $of
       echo >> $of
       echo "$Sstats"  |gawk '{printf("mmSTN:  STRT: %" "2d  %s\n","'"$nSTRT"'"+0, $0 )}' >> $of
       echo "$OTstats" |gawk '{print "mmOT:            ",$0}' >> $of
       echo >> $of
       echo "$Xstats"  |gawk '{print "mmX:             ",$0}' >> $of
       echo "$Ystats"  |gawk '{print "mmY:             ",$0}' >> $of
       echo "$nwDstats"  |gawk '{print "mmD:             ",$0}' >> $of
       echo "$Vstats"  |gawk '{print "mmV:             ",$0}' >> $of
       echo >> $of

#T      cat $of
#T echo "SUMMARY:  $NVTID"
#T       set S = ` echo $Sstats |gawk '{print $8}' `
#T       set Siqr = ` echo $Sstats |gawk '{print $14}' `
#T       set OT = ` echo $OTstats |gawk '{print $8}' `
#T       set OTiqr = ` echo $OTstats |gawk '{print $14}' `
#T       set X = ` echo $Xstats |gawk '{print $8}' `
#T       set Xiqr = ` echo $Xstats |gawk '{print $14}' `
#T       set Y = ` echo $Ystats |gawk '{print $8}' `
#T       set Yiqr = ` echo $Ystats |gawk '{print $14}' `
#T       set D = ` echo $Dstats |gawk '{print $8}' `
#T       set Diqr = ` echo $Dstats |gawk '{print $14}' `
#T       set nwD = ` echo $nwDstats |gawk '{print $8}' `
#T       set nwDiqr = ` echo $nwDstats |gawk '{print $14}' `
#T       set V = ` echo $Vstats |gawk '{print $8}' `
#T       set Viqr = ` echo $Vstats |gawk '{print $14}' `
#T       echo "$NVTID  $X $Y $nwD $V $Xiqr $Yiqr $nwDiqr $Viqr $S $Siqr"|\
#T gawk '{printf("%s  %" "4.1f %" "4.1f %" "4.1f %" "5.2f   %" "5.2f %" "5.2f %" "5.2f %" "6.3f   %.3f %.3f\n",\
#T           $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11 )}'

#T## Compare to previous result: 
#T      echo "$NVTID " ` cat ../../V9/DAT_"$NVTID"/*D/dat.gp*select*fnl*two `
#T      echo "$NVTID " ` cat ../../V9/DAT_"$NVTID"/*D/dat.gp*select*fnl*three `


#D     -------------------------------------------------------------------------------
#D     + FOUND GRID-POINT now REMOVE OUTLIERS
#D     -------------------------------------------------------------------------------
#D    = FIRST get OT stats corresponding to statistical gp location 
#D      (i.e., Q1, median, Q3, IQR and +- 1.5Mfs)
#D      . It is possible that there is NO grid-point with viable Vest correstponding
#D        to a statisitcal gp location. This is delt with as follows:
#D          IF NO gp, 
#D          THEN search adjacent gp's in surrounding shells (up to 'mxShell')
#D               until one is found.
#D          ENDIF
#D      . The statistical gp is also a median and it is possible that the median value
#D          exists exactly halfway between actual gp values. Therefore using dS = 1.0
#D           which is half the grid-search interval.
#D      . Should either 0 or 1 gp, if there are more then there is a bug someplace.
#D      . Should have used modulus (%) to avoid taking median of even number of records
#D         but didn't.  Maybe on revision later. Would simplify this mess.
#D
#D    (OTPT: dat.gp-select-fnl.OT.two )
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
  
      set if1 = dat.gp-select.OT.two
      set if2 = dat.gp-search.OT.two
      set of  = dat.gp-select-fnl.OT.two
      set dS = 1.0; #echo "gp increment for search if NO statistical gp" 
      set mxShell = 10; #echo "Max of surrounding shells searched"
      gawk 'BEGIN{\
        i=j=k=u=0+0;\
        ds=sprintf("%.1f","'"$dS"'"+0.);\
        mxsh=sprintf("%d","'"$mxShell"'"+0 );\
      }{\
        if(FILENAME=="'"$if1"'"){\
          if($0 ~ /mmX\:   /){x=sprintf("%.1f", $9+0. )};\
          if($0 ~ /mmY\:   /){y=sprintf("%.1f", $9+0. )};\
          if($0 ~ /mmD\:   /){d=sprintf("%.1f", $9+0. )};\
        }\
        if(FILENAME=="'"$if2"'"){\
          i=i+1;\
          lin[i]=$0;\
        }\
      }END{\
        otpt="";\
        # Set up surrounding gp s to search;\
        shell=0+0;\
        xx=0+0;\
        yy=0+0;\
        dd=0+0;\
        for(shell=(1+0);(shell+0)<=(mxsh+0);shell=(shell+1)){\
          for(dd=(1*shell);dd>=(-1*shell);dd=dd-1){\
          for(xx=(-1*shell);xx<=(1*shell);xx=xx+1){\
          for(yy=(-1*shell);yy<=(1*shell);yy=yy+1){\
            k=k+1;\
            x2[k]=sprintf("%.1f",x+(xx*ds) );\
            y2[k]=sprintf("%.1f",y+(yy*ds) );\
            d2[k]=sprintf("%.1f",d+(dd*ds) );\
          }\
          }\
          }\
        }\
        # Loop until gp found;\
        x0=sprintf("%.1f", x+0. );\
        y0=sprintf("%.1f", y+0. );\
        d0=sprintf("%.1f", d+0. );\
        while(length(otpt)==0+0 && u+0 <= k+0){\
          for(j=1;j<=i;j++){\
            split(lin[j],a);\
            if(a[1]+0. == x0+0.){\
            if(a[2]+0. == y0+0.){\
            if(a[3]+0. == d0+0.){\
              otpt=sprintf("%s", lin[j] );\
            }\
            }\
            }\
          }\
      #print "== ",x,y,d;\
      #print x0,y0,d0,length(otpt);\
          if(length(otpt)==0+0){\
            u=u+1;\
            x0=sprintf("%.1f", x2[u]+0. );\
            y0=sprintf("%.1f", y2[u]+0. );\
            d0=sprintf("%.1f", d2[u]+0. );\
          }\
        }\
        print otpt;\
      }' $if1 $if2 |tee $of


#D    = SECOND OT stats (stage three) for:
#D      1) All stations;
#D      2) All above mnXC
#D      3) RELIABLE (i.e., above mnXCconsidered and outlier filter applied)
#D      4) Most RELIABLE (i.e., above mnXCf and aoutlier filter applied
#D      This is where I used the Q1,MED,Q3, and IQR of the OTs from gp_s 
#D        to select potential additional stations.
#D  (OTPT: dat.OTall
#D         dat.OTall.mnXC-{mnXCconsider}
#D         dat.OT.RELIABLE
#D         dat.OT.ORG-RELIABLE )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
    set mnXConsider = "0.40"
    set mnXCconsider = "0.30"; echo "USE"
    set if1 = dat.gp-select-fnl.OT.two
    set if2 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL
    set if3 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-"$mnXCf"
    set vlpSPS = "10";  echo "km/sec"
    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
  echo "Use only REFINED grid-point"
    set oX = ` gawk '{printf("%f", ($1+0.) )}' $if1 `
    set oY = ` gawk '{printf("%f", ($2+0.) )}' $if1 `
    set oD = ` gawk '{printf("%f", ($3+0.) )}' $if1 `
    set oV = ` gawk '{printf("%f", ($6+0.) )}' $if1 `
    set Q1  = ` gawk '{printf("%f", ($12+0.) )}' $if1 `
    set MED = ` gawk '{printf("%f", ($14+0.) )}' $if1 `
    set Q3  = ` gawk '{printf("%f", ($16+0.) )}' $if1 `
    set IQR = ` gawk '{printf("%f", ($20+0.) )}' $if1 `
    set Mfs = 1.50; echo "--USE(1.50)--: Multiplication factor of fs for outlier determination"
    set lwCUT = `echo $Mfs $IQR $Q1 |gawk '{printf("%f",$3-($1*$2) )}'`
    set hgCUT = `echo $Mfs $IQR $Q3 |gawk '{printf("%f",$3+($1*$2) )}'`
    set mnOT = -999.9
    set mxOT =  999.9
    "$utl"/mOTstats.v2 $if2 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Vflg \
      |tee dat.OTall |cat -n
    gawk '{if($11+0. >= "'"$mnXCconsider"'"+0. ){print $0}}' dat.OTall \
      |tee dat.OTall.mnXC-"$mnXCconsider" |cat -n
    gawk '{\
      if("'"$lwCUT"'"+0. <= $1+0. && $1+0. <= "'"$hgCUT"'"+0.){print $0} \
    }' dat.OTall.mnXC-"$mnXCconsider"  \
      |tee dat.OT.RELIABLE |cat -n
    "$utl"/mOTstats.v2 $if3 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Vflg |\
      gawk '{if("'"$lwCUT"'"+0. <= $1+0. && $1+0. <= "'"$hgCUT"'"+0.){print $0}}' \
      |tee dat.OT.ORG-RELIABLE |cat -n
    echo $lwCUT $hgCUT


#D   -------------------------------------------------------------------------------
#D   + REFINE a SECOND TIME using RELAIABLE stations from (dat.OT.RELIABLE)
#D   -------------------------------------------------------------------------------
#D  - Vest grid-search three
#D    . Vest for REFINE/REDUCED ZONE 
#D    . For X and Y ranges,  use MIN-4. and MAX+4. values of mmX and mmY in: dat.gp-search.OT.two
#D  (OTPT: dat.gp-search.Vest.three )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD
    
    set runt0 = `date +%Y.%j,%T`
    set SWP = three
    set of = dat.gp-search.Vest."$SWP"
    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
    set if1 = dat.gp-select-fnl.OT.two
    set if1b = dat.gp-select.OT.two
    set if0 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL
    set if00 = dat.OT.RELIABLE
    gawk '{printf(" %s \n",$3 )}' $if00 > tmp.fgrp.$$
    egrep -f tmp.fgrp.$$ $if0 > l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_RELIABLE
    set if2 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_RELIABLE
    set vlpSPS = "10";  echo "km/sec"
    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
    set mnSEP = 00.0; echo "Travel Path differences of station-pairs w/ gp USE"
  echo "Vest GRID-SEARCH"
    /bin/rm $of; touch $of
  echo "Loop over grid-points"
#   set mnX = `gawk '{printf("%f", ($1-24.) )}' $if1`
#   set mxX = `gawk '{printf("%f", ($1+24.) )}' $if1`
#   set mnY = `gawk '{printf("%f", ($2-24.) )}' $if1`
#   set mxY = `gawk '{printf("%f", ($2+24.) )}' $if1`
    set mnX = ` egrep '^mmX\: ' $if1b |gawk '{printf("%f", ($5-4.) )}' `
    set mxX = ` egrep '^mmX\: ' $if1b |gawk '{printf("%f", ($13+4.) )}' `
    set mnY = ` egrep '^mmY\: ' $if1b |gawk '{printf("%f", ($5-4.) )}' `
    set mxY = ` egrep '^mmY\: ' $if1b |gawk '{printf("%f", ($13+4.) )}' `
    set dX = 2.
    set dY = 2.
    set mnD =  4.; 
    set mxD = 36.; 
    set dD =  2.
    foreach oX (` echo $mnX $mxX $dX|gawk '{for(x=$1+0.;x<=$2+0.;x=x+$3+0.){printf("%.1f\n",x )}}' `)
    foreach oY (` echo $mnY $mxY $dY|gawk '{for(y=$1+0.;y<=$2+0.;y=y+$3+0.){printf("%.1f\n",y )}}' `)
    foreach oD (` echo $mnD $mxD $dD|gawk '{for(d=$1+0.;d<=$2+0.;d=d+$3+0.){printf("%.1f\n",d )}}' `)
      echo -n $oX $oY $oD":  " |tee -a $of
      "$utl"/mVest.stats $if2 $oX $oY $oD $vlpSPS $Vflg $mnSEP |\
        "$utl"/mmed4 |tee -a $of
    end
    end
    end
    set runtf = `date +%Y.%j,%T`
    set runtime = `caldate -f %H:%M:%S.%F -d -- $runtf $runt0`
    echo "RUNTIME:  $runtime"


#D  + SELECT viable gp's from Vest search three
#D    #IQR and Standard Error minimize:
#D      SE=SD/sqrt(N-1)
#D      SD=IQR/1.35
#D     so,
#D      SE=(IQR/1.35)/sqrt(N-1)
#D     SELECTION FORMULA:
#D       . SE < mxSE (e.g., 0.20)
#D       . Minimum number of readings at least >= mnPAIR (e.g., 4) (very low needed for v. sparce data set)
#D       . Max of MXgp (e.g., 1500 for SWP two) gp's having largest number of readings
#D          = Larger number of readings indicates the gp is in a region where
#D            the travel-times to the most stations falls w/i an expected range
#D            (i.e., 2.5 to 4.0 km/s).
#D          = This is for a 41 x 41 x 7 == 11767 point grid)
#D          = Some situations will have significantly less than MXgp viable gp's
#D            (particularly if few recorded stations)
#D          = We initially need to examine a lot of gp possibilities because
#D            when scrounging the initial set of assumed reliable (XC based)
#D            stations may very well contain an outlier or two which will result
#D            is several possible regions of viable Vest's.  Outliers will be
#D            identified and excluded as part of the subsequent oT analysis.
#D  (OTPT:  dat.gp-select.Vest.three )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set SWP = three
    set if = dat.gp-search.Vest."$SWP"
    set mnPAIR = 4
    set mxSE = 0.20
    set MXgp = 1500
    gawk 'BEGIN{\
      mnpair=sprintf("%d","'"$mnPAIR"'"+0 );\
      mxse=sprintf("%f","'"$mxSE"'"+0. );\
    }{\
      N=sprintf("%f", $5+0. );\
      IQR=sprintf("%f", $17+0. );\
      if(N+0. >= mnpair+0.){\
        SE=sprintf("%f", (IQR/1.35)/(sqrt(N-1))+0. );\
        if(SE+0. < mxse+0.){\
          print $0,SE ;\
        }\
      }\
    }' $if |\
    sort -k 5,5n |tail -"$MXgp" |tee dat.gp-select.Vest."$SWP"


#D  - OT grid-search three
#D    . OT for REFINE/REDUCED ZONE 
#D  (OTPT: dat.gp-search.OT.three )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD
    set runt0 = `date +%Y.%j,%T`

    set SWP = three
    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
    set if1 = dat.gp-select.Vest."$SWP"
    set if2 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_RELIABLE
    set of  = dat.gp-search.OT."$SWP"
    set vlpSPS = "10";  echo "km/sec"
    set mxNit = 15; echo "Maximum of iterations to deal with oscillations"
    set Mfs = 1.5; echo "Multiplication factor of fs for outlier determination"
    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
    /bin/rm $of; touch $of 
  echo "Loop over grid-points"
    cat $if1 |sed 's/\:/ /g' |\
      gawk '{\
        printf("%.1f_%.1f_%.1f_%f\n",$1,$2,$3,$11 );\
      }' > tmp.gps-xydv.$$
    foreach lst (` cat tmp.gps-xydv.$$ `)
      set oX = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $1 )}' `
      set oY = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $2 )}' `
      set oD = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%.1f", $3 )}' `
      set oV = ` echo $lst |sed 's/\_/ /g' |gawk '{printf("%f", $4 )}' `
      set Nit = "0"
      set mnOT = -999.9
      set mxOT =  999.9
      echo $mnOT $mxOT
      set str0 = \
        ` "$utl"/mGRIDsearch.v3 $if2 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Mfs $Vflg `
      set Ndat0 = `echo $str0 |gawk '{printf("%d",$8 )}'`
      set Nit = `echo "$Nit" |gawk '{printf("%d",$1+1)}'`
      if ( $Ndat0 < 7 ) then
        echo "___ WARNING: TO FEW DATA POINTS ($Ndat0 < 7), at: ___"
        echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
        echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
        echo "___ GRID-POINT NOT ESTIMATED___"
        continue
      endif
      if ( $Ndat0 == 7 ) then
        echo "___ WARNING: DATA POINTS == 7 at: ___"
        echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
        echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
        echo "___ GRID-POINT ESTIMATION STOPPED and OUTPUT___"
        echo $str0 $Nit |tee -a $of 
        continue
      endif

  echo "Iterative outlier removal"
      set alreadyprinted = "N"
      while ( $Ndat0 > 7 )
        set mnOT = `echo $str0 |gawk '{print $4}'`
        set mxOT = `echo $str0 |gawk '{print $5}'`
        set str2 = \
          `"$utl"/mGRIDsearch.v3 $if2 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Mfs $Vflg`
        set Ndat2 = `echo $str2 |gawk '{printf("%d",$8 )}'`
        set Nit = `echo "$Nit" |gawk '{printf("%d",$1+1)}'`
        if ( $Ndat2 < 7 ) then
          echo "___ WARNING: TO FEW DATA POINTS ($Ndat2 < 7), at later iteration: ___"
          echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
          echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
          echo "___ OUTPUTTING PREVIOUS ITERATION GRID-POINT ESTIMATE___"
          echo $str0 $Nit |tee -a $of 
          set alreadyprinted = "Y"
          break
        else if ( $Ndat2 == 7 ) then
          echo "___ WARNING: DATA POINTS == 7 at later iteration ___"
          echo "___ (oV mnXCf oX oY oD mnOT mxOT): ___"
          echo "___ $oV $mnXCf $oX $oY $oD   $mnOT $mxOT ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          echo $str2 $Nit |tee -a $of 
          set alreadyprinted = "Y"
          break
        else if ( "$Ndat2" == "$Ndat0" ) then
          echo "___ IDENTICAL RESULTS TO PREVIOUS ITERATION ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          break
        else if ( "$Nit" >= "$mxNit" ) then
          echo "___ MAXIMUM ALLOWED ITERATIONS (mnNit) REACHED ___"
          echo "___ OUTPUTTING GRID-POINT ESTIMATE; DONE ITERATING___"
          break
        else 
          set str0 = "$str2"
          set Ndat0 = "$Ndat2"
        endif
      end
      if ( $alreadyprinted == "N" ) then
         echo $str0 $Nit |tee -a $of 
      endif
      set alreadyprinted = "N"
    end
    echo "Vel: $oV   mnXCf: $mnXCf"
    set runtf = `date +%Y.%j,%T`
    set runtime = `caldate -f %H:%M:%S.%F -d -- $runtf $runt0`
    echo "RUNTIME:  $runtime"


#D     -------------------------------------------------------------------------------
#D     + SECOND REFINE GRID-POINT SELECTION: IQR-Nit TRADE-OFF (aka): Evaluation tests w/ iterations
#D     -------------------------------------------------------------------------------
#D     REVISED, SEE: 
#D        Stage two "REFINED GRID-POINT SELECTION: IQR-Nit TRADE-OFF ..." for detail (borrowed from there)
#D S=== OBSOLETE
#D     (OTPT: dat.gp-select.OT.three )
#D       cd $datDIR
#D       cd DAT_"$NVTID"
#D       cd DAT.TRMD
#D
#D       set SWP = three
#D       set if = dat.gp-search.OT."$SWP"
#D       set of = dat.gp-select.OT."$SWP"
#D       set previf = dat.gp-select.OT.two
#D       set mnIQR = 0.0; set mxIQR = 3.5
#D       set mnNstn = "7"
#D       set cutIQR = "2.8"
#D       set cutNit = "1"; echo "starting Nit value"
#D       set cutNdat = "27"; echo "USE"
#D       set cutNdat = "54"; echo "USE"
#D       set cutNdat = "81"; echo "USE"
#D       set cutNdat = "125"; echo "(25 gp's per layer x 5 layers of surrounding gp's :: USE)"
#D
#D        #4 USE:
#D       set mnIQR = 0.0; set mxIQR = 3.5; echo "ORG150718"
#D       set cutIQR = "3.2"; echo "ORG140718"
#D       set cutNdat = "123"; echo "(25 gp's per layer x 5 layers of surrounding gp's :: USE)"
#D       set cutNdat2 = `echo $cutNdat |gawk '{printf("%d",$1/2)}'`
#D       "$utl"/m.nit-iqr-trade.v4 $utl $mnIQR $mxIQR $mnNstn \
#D                              $cutIQR $cutNit $cutNdat $cutNdat2 $if  |tee $of
#D       echo; echo "first-REFINED: ";tail -10 $previf
#D E=== OBSOLETE
#D
#D     REVISED  IQR-Nit  TRADE-OFF  stage two (aka. m.nit...)
#D     RATIONAL (see IQR-Nit TRADE-OFF for stage "one" above)
#D       So, PLAN for happy medium:
#D       CAUTION (150722 modifications made)
#D          1. Set mnSTN = 12;   mnREC=27; mxIQR==4.;  MAXNIT=4, (smallest NIT is 2 by default).
#D          2. Compute SE and integer value of SE (seINT) for sorting.
#D          3. Compute integer value of OT (otINT) for sorting. 
#D          4. Save gp records with <= MAXNIT && IQR <= mxIQR
#D          5. Among data from step 4, count and save separately those records with >= mnSTN
#D          6. IF number of records from step 5 is >= mnREC, 
#D               sort otINT(larges-negative to lowest-negative(bottom)), nstns(low to high(bottom), 
#D                    and seINT (highest to lowest(bottom))  
#D               keep last mnREC records
#D               Compute statistical gp location inforation
#D               Save result
#D               exit
#D          7. If number of records < mnREC && NIT != 2,
#D               decrement NIT and repeat from step 4.
#D          8. If number of records < mnREC && NIT == 2 (ie., the minimum possible)
#D               sort otINT(larges-negative to lowest-negative(bottom)), nstns(low to high(bottom), 
#D                    and seINT (highest to lowest(bottom))  
#D               keep all records
#D               Compute statistical gp location inforation
#D               Save result
#D               exit
#D          *NOTE: For stage "two", am trimming the v. low 25% of OTs (least neg.) since they bias 
#D                 the results to shallow depths.  More depth bias reduction planned for stage "three"
#D       PERSPECTIVE 150729:  
#d         Why do I need accurated gp_s?
#D         I need the range of associated OT estimates (Q1,Q3,IQR) to use in box-plot
#D           filtering for selection of other lower XC stations based on their OTs.  
#D         So at this point, getting reasonable depths is also important.
#D         Therefore adding means for estimating depths after lat-lons obtained.
#D     (OTPT: dat.gp-select.OT.three )
#D     (OTPT: dat.gp-select.fnl.LOC.three )
       cd $datDIR
       cd DAT_"$NVTID"
       cd DAT.TRMD

       set SWP = three
       set if = dat.gp-search.OT."$SWP"
       set of = dat.gp-select.OT."$SWP"
       set of2 = dat.gp-select.fnl.LOC."$SWP"
       set previf = dat.gp-select.OT.two

    ## Data to start with
       set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
       set mnSTN = 12;# echo "USE, 150722 same as stage "one"
       set mxIQR = 3.5;# echo "USE, 150722"
       set MAXNIT = 4;# echo "USE, 150722: maximum NIT value allowed.  Higher usually means poor convergence"
       set mnREC = 250;# echo "USE, 150722 greater number than stage "one" because denser gp's"
# USE: Using mnREC of 27, sorting on OT and keeping the first w1 then w2 OTs removes xx% of shortest TTs
       set mnREC = 27;# echo "USE, 150727 greater number than stage "one" because denser gp's"
       cat $if |\
       gawk 'BEGIN{\
         minstn=sprintf("%d","'"$mnSTN"'"+0 );\
         minrec=sprintf("%d","'"$mnREC"'"+0 );\
         mxiqr=sprintf("%f","'"$mxIQR"'"+0. );\
         MAXNIT=sprintf("%d","'"$MAXNIT"'"+0 );\
         i=0+0;\
       }{\
         i=i+1;\
         nstn=sprintf("%d",$8+0);\
         iqr=sprintf("%f",$20+0.);\
         SE=sprintf("%f",(iqr/1.35)/sqrt(nstn-1) );\
         seINT=sprintf("%f",int((10*SE)+0.5)+0 );\
         otINT=sprintf("%f",int($14-0.5)+0 );\
         lin[i]=sprintf("%s %f %d %d\n", $0,SE,seINT,otINT );\
       }END{\
         NIT=MAXNIT+0;\
         while(NIT+0 >= 2+0){\
           nrec=nraw=0+0;\
           for(j=1;j<=i;j++){\
             split(lin[j],a);\
             iqr=a[20]+0.;\
             nit=a[21]+0;\
             nsta=a[8]+0;\
             if(nit+0 <= NIT+0 && iqr+0. <= mxiqr+0.){\
               nraw=nraw+1;\
               otptraw[nraw]=lin[j];\
               if(nsta+0 >= minstn+0 ){\
                 nrec=nrec+1;\
                 otpt[nrec]=lin[j];\
               }\
             }\
           }\
           if(nrec+0 >= minrec+0){\
             for(k=1;k<=nrec;k++){\
               printf("%s", otpt[k] );\
             }\
             exit;\
           }\
           if(NIT+0 == 2+0){\
             for(k=1;k<=nraw;k++){\
               printf("%s", otptraw[k] );\
             }\
             exit;\
           }\
           NIT=NIT-1;\
         }\
       }' > tmp.3A.$$


    ## gp-location Stats (X,Y and D)
       # Most STNs
       sort -k 8,8n tmp.3A.$$ > tmp.3B.$$;                         
       set fract = .20
       set fract = .05
       set fract = .30
       set fract = .10;# echo "STNDRD"
       set lrgNstn = ` sed -n '$,$p' tmp.3B.$$ |gawk '{print $8+0}' `
       set fN = `echo $fract  $lrgNstn |gawk '{printf("%d",$1*$2+0 )}' `
       gawk '{ if($8+0 >= ("'"$lrgNstn"'"-"'"$fN"'"+0) ){print $0} }' tmp.3B.$$ > tmp.3C.$$
   #cat -n tmp.3C.$$ 
   #head -3 tmp.3C.$$;echo "---"; tail -3 tmp.3C.$$

       # Then central range of IQRs (20,20nr --> smallest iqr's at bottom)
       set Nodd = ` gawk '{}END{if((NR%2.) == 0+0){print NR-1}else{print NR+0}}' tmp.3C.$$ `
       tail -"$Nodd" tmp.3C.$$ > tmp.3C-odd.$$
       set midIQR = ` gawk '{print $20+0.}' tmp.3C-odd.$$ |$utl/mmed4 |gawk '{print $8+0.}' `
       set N8th = `wc tmp.3C.$$ | gawk '{printf("%d\n",($1/8) )}' `
       sort -k 20,20nr tmp.3C.$$ |\
         gawk 'BEGIN{\
           i=0+0;\
           pm=sprintf("%d","'"$N8th"'"+0);\
           midiqr=sprintf("%f","'"$midIQR"'"+0.);\
           Nmid=sprintf("%d",0+0 );\
         }{\
           i=i+1;\
           rec[i]=$0;\
           if(midiqr-0.0005 <= $20+0. && $20+0. <= midiqr+0.0005){Nmid=i+0}\
         }END{\
           for(j=Nmid-(3*pm); j<= Nmid+(3*pm); j=j+1){\
             print rec[j];\
           }\
         }'  > tmp.3D.$$

       # Then central range of OTs (14,14n --> largest (least neg.) OTs at bottom )
       set Nodd = ` gawk '{}END{if((NR%2.) == 0+0){print NR-1}else{print NR+0}}' tmp.3D.$$ `
       tail -"$Nodd" tmp.3D.$$ > tmp.3D-odd.$$
       set midOT = ` gawk '{print $14+0.}' tmp.3D-odd.$$ |$utl/mmed4 |gawk '{print $8+0.}' `
       set N8th = `wc tmp.3D.$$ | gawk '{printf("%d\n",($1/8) )}' `
       sort -k 14,14n tmp.3D.$$ |\
         gawk 'BEGIN{\
           i=0+0;\
           pm=sprintf("%d","'"$N8th"'"+0);\
           midot=sprintf("%f","'"$midOT"'"+0.);\
           Nmid=sprintf("%d",0+0 );\
         }{\
           i=i+1;\
           rec[i]=$0;\
           if(midot-0.0005 <= $14+0. && $14+0. <= midot+0.0005){Nmid=i+0}\
         }END{\
           for(j=Nmid-(3*pm); j<= Nmid+(3*pm); j=j+1){\
             print rec[j];\
           }\
         }'  > tmp.3E.$$
  # cat -n tmp.3E.$$ 

    ## Summary Statistics
       set Nodd = ` gawk '{}END{if((NR%2.) == 0+0){print NR-1}else{print NR+0}}' tmp.3E.$$ `
       tail -"$Nodd" tmp.3E.$$ > tmpx.$$
       set Ngps    = ` wc tmpx.$$ |gawk '{print $1}' `
       set nSTRT = ` wc l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL_mnXC-"$mnXCf" |gawk '{printf("%d",$1+0.)}' `
       set Sstats  = ` gawk '{print $8}'  tmpx.$$ |"$utl"/mmed4 `
       set OTstats = ` gawk '{print $14}'  tmpx.$$ |"$utl"/mmed4 `
       set Xstats  = ` gawk '{print $1}'  tmpx.$$ |"$utl"/mmed4 `
       set Ystats  = ` gawk '{print $2}'  tmpx.$$ |"$utl"/mmed4 `
       set Dstats  = ` gawk '{print $3}'  tmpx.$$ |"$utl"/mmed4 `
       set Vstats  = ` gawk '{print $6}'  tmpx.$$ |"$utl"/mmed4 `

    ## Output: dat.gp-select.OT.three 
    ## Output: dat.gp-select.fnl.LOC.three
       echo "Data Used:" > $of
       cat tmpx.$$ >> $of
       echo >> $of
       echo "NVTID:  $NVTID" >> $of
       echo >> $of
       echo "$Sstats"  |gawk '{printf("mmSTN:  STRT: %" "2d  %s\n","'"$nSTRT"'"+0, $0 )}' >> $of
       echo "$OTstats" |gawk '{print "mmOT:            ",$0}' >> $of
       echo >> $of
       echo "$Xstats"  |gawk '{print "mmX:             ",$0}' >> $of
       echo "$Ystats"  |gawk '{print "mmY:             ",$0}' >> $of
       echo "$Dstats"  |gawk '{print "mmD:             ",$0}' >> $of
       echo "$Vstats"  |gawk '{print "mmV:             ",$0}' >> $of
       echo >> $of
     cat $of

    ## Output: dat.gp-select.fnl.LOC.three
       set S = ` echo $Sstats |gawk '{print $8}' `
       set Siqr = ` echo $Sstats |gawk '{print $14}' `
       set OT = ` echo $OTstats |gawk '{print $8}' `
       set OTiqr = ` echo $OTstats |gawk '{print $14}' `
       set X = ` echo $Xstats |gawk '{print $8}' `
       set Xiqr = ` echo $Xstats |gawk '{print $14}' `
       set Y = ` echo $Ystats |gawk '{print $8}' `
       set Yiqr = ` echo $Ystats |gawk '{print $14}' `
       set D = ` echo $Dstats |gawk '{print $8}' `
       set Diqr = ` echo $Dstats |gawk '{print $14}' `
       set V = ` echo $Vstats |gawk '{print $8}' `
       set Viqr = ` echo $Vstats |gawk '{print $14}' `
    echo "00A      NVTID            X    Y    D    V    Ngps   Xiqr  Yiqr  Diqr  Viqr     S     Siqr" \
       > $of2
    echo "$NVTID  $X $Y $D $V $Ngps $Xiqr $Yiqr $Diqr $Viqr $S $Siqr"|\
  gawk '{\
  printf("%s  %" "4.1f %" "4.1f %" "4.1f %" "5.2f  %" "3d   %" "5.2f %" "5.2f %" "5.2f %" "6.3f   %.3f %.3f\n",\
  $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12 )}' \
      >> $of2
  echo; cat $of2; echo

#T## Compare to previous result: 
#T      echo "$NVTID " ` cat ../../V9/DAT_"$NVTID"/*D/dat.gp*select*fnl*two `
#T      echo "$NVTID " ` cat ../../V9/DAT_"$NVTID"/*D/dat.gp*select*fnl*three `



#D     -------------------------------------------------------------------------------
#D     + FOUND SECOND REFINE GRID-POINT now REMOVE OUTLIERS
#D     -------------------------------------------------------------------------------
#D    = FIRST--RELIABLE REFINED: get OT stats corresponding to statistical gp location 
#D      (i.e., Q1, median, Q3, IQR and +- 1.5Mfs)
#D      . Depths tend to bias shallow in multi-mode reduction used above, so 
#D        using Q3 rather than MED depth to reduce this effect.
#D      . It is possible that there is NO grid-point with viable Vest correstponding
#D        to a statisitcal gp location. This is delt with as follows:
#D          IF NO gp, 
#D          THEN search adjacent gp's in surrounding shells (up to 'mxShell')
#D               until one is found.
#D          ENDIF
#D      . The statistical gp is also a median and it is possible that the median value
#D          exists exactly halfway between actual gp values. Therefore using dS = 1.0
#D           which is half the grid-search interval.
#D      . Should either 0 or 1 gp, if there are more then there is a bug someplace.
#D
#D    (OTPT: dat.gp-select-fnl.OT.three )
      cd $datDIR
      cd DAT_"$NVTID"
      cd DAT.TRMD
  
      set if1 = dat.gp-select.OT.three
      set if2 = dat.gp-search.OT.three
      set of  = dat.gp-select-fnl.OT.three
      set dS = 1.0; echo "gp increment for search if NO statistical gp" 
      set mxShell = 10; echo "Max of surrounding shells searched"
      gawk 'BEGIN{\
        i=j=k=u=0+0;\
        ds=sprintf("%.1f","'"$dS"'"+0.);\
        mxsh=sprintf("%d","'"$mxShell"'"+0 );\
      }{\
        if(FILENAME=="'"$if1"'"){\
          if($0 ~ /mmX\:   /){x=sprintf("%.1f", $9+0. )};\
          if($0 ~ /mmY\:   /){y=sprintf("%.1f", $9+0. )};\
          if($0 ~ /mmD\:   /){d=sprintf("%.1f", $9+0. )};\
        }\
        if(FILENAME=="'"$if2"'"){\
          i=i+1;\
          lin[i]=$0;\
        }\
      }END{\
        otpt="";\
        # Set up surrounding gp s to search;\
        shell=0+0;\
        xx=0+0;\
        yy=0+0;\
        dd=0+0;\
        for(shell=(1+0);(shell+0)<=(mxsh+0);shell=(shell+1)){\
          for(dd=(1*shell);dd>=(-1*shell);dd=dd-1){\
          for(xx=(-1*shell);xx<=(1*shell);xx=xx+1){\
          for(yy=(-1*shell);yy<=(1*shell);yy=yy+1){\
            k=k+1;\
            x2[k]=sprintf("%.1f",x+(xx*ds) );\
            y2[k]=sprintf("%.1f",y+(yy*ds) );\
            d2[k]=sprintf("%.1f",d+(dd*ds) );\
          }\
          }\
          }\
        }\
        # Loop until gp found;\
        x0=sprintf("%.1f", x+0. );\
        y0=sprintf("%.1f", y+0. );\
        d0=sprintf("%.1f", d+0. );\
        while(length(otpt)==0+0 && u+0 <= k+0){\
          for(j=1;j<=i;j++){\
            split(lin[j],a);\
            if(a[1]+0. == x0+0.){\
            if(a[2]+0. == y0+0.){\
            if(a[3]+0. == d0+0.){\
              otpt=sprintf("%s", lin[j] );\
            }\
            }\
            }\
          }\
      #print "== ",x,y,d;\
      #print x0,y0,d0,length(otpt);\
          if(length(otpt)==0+0){\
            u=u+1;\
            x0=sprintf("%.1f", x2[u]+0. );\
            y0=sprintf("%.1f", y2[u]+0. );\
            d0=sprintf("%.1f", d2[u]+0. );\
          }\
        }\
        print otpt;\
      }' $if1 $if2 |tee dat.gp-select-fnl.OT.three


#D    = SECOND--SECOND REFINE: OT stats for:
#D      1) All stations;
#D      2) All w/ above mnXC
#D      3) RELIABLE series (i.e., above mnXC and series of Mf-outlier filters 
#D         applied using the fixed Q1,Q3 and IQR info from: dat.gp-select-fnl.OT.three )
#D  (OTPT: dat.OTall.refine2
#D         dat.OTall.mnXC-{mnXCconsider}.refine2
#D         dat.OT.RELIABLE.Mfs_{Mfs} )
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set mnXCf = `cat l.mnXCinfo |gawk '{printf("%4.2f",$1+0. )}'`
    set mnXCconsider = "0.40"
    set mnXCconsider = "0.30"; echo "STANDARD"
    set if1 = dat.gp-select-fnl.OT.three
    set if2 = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL
    set vlpSPS = "10";  echo "km/sec"
    set Vflg = "ON"; echo "Verbose Flag (ON or OFF)"
    set Vflg = "OFF"; echo "Verbose Flag (ON or OFF)"
  echo "Use only REFINED grid-point"
    set oX = ` gawk '{printf("%f", ($1+0.) )}' $if1 `
    set oY = ` gawk '{printf("%f", ($2+0.) )}' $if1 `
    set oD = ` gawk '{printf("%f", ($3+0.) )}' $if1 `
    set oV = ` gawk '{printf("%f", ($6+0.) )}' $if1 `
    set Q1  = ` gawk '{printf("%f", ($12+0.) )}' $if1 `
    set MED = ` gawk '{printf("%f", ($14+0.) )}' $if1 `
    set Q3  = ` gawk '{printf("%f", ($16+0.) )}' $if1 `
    set IQR = ` gawk '{printf("%f", ($20+0.) )}' $if1 `
    set mnOT = -999.9
    set mxOT =  999.9
    "$utl"/mOTstats.v2 $if2 $oX $oY $oD $oV $vlpSPS $mnOT $mxOT $Vflg \
      |tee dat.OTall.refine2 |cat -n
    gawk '{if($11+0. >= "'"$mnXCconsider"'"+0. ){print $0}}' dat.OTall.refine2 \
      |tee dat.OTall.mnXC-"$mnXCconsider".refine2 |cat -n
    foreach Mfs (5.00 4.50 4.00 3.50 3.00 2.50 2.00 1.50 1.00 0.50)
      set lwCUT = `echo $Mfs $IQR $Q1 |gawk '{printf("%f",$3-($1*$2) )}'`
      set hgCUT = `echo $Mfs $IQR $Q3 |gawk '{printf("%f",$3+($1*$2) )}'`
      echo "---"dat.OT.RELIABLE.Mfs_"$Mfs""---"
      echo -n "00A (Mfs,lwCUT,hgCUT): $Mfs $lwCUT $hgCUT" |tee dat.OT.RELIABLE.Mfs_"$Mfs"
      echo "     (Q1,MED,Q3,IQR):   $Q1  $MED  $Q3    $IQR" |tee -a dat.OT.RELIABLE.Mfs_"$Mfs"
      gawk '{\
        if("'"$lwCUT"'"+0. <= $1+0. && $1+0. <= "'"$hgCUT"'"+0.){print $0} \
      }' dat.OTall.mnXC-"$mnXCconsider".refine2  \
        |tee -a dat.OT.RELIABLE.Mfs_"$Mfs" |cat -n
    end
    cat $if1
#mkDAT stop
endif

echo "B3333"

#DS===:: OPTIONAL ::
#DS===:: OPTIONAL ::
      if ( "$mkPLOTs" == "Y" ) then


#D  = PLOT  LAGs as color
#D    + Adaptive:
#D      . Map center is center of LL ' Range ' (not average) of stations
#D      . Size of region should be fixed ito Range of degrees
#D      . Station names included (either STN or STN.NT)
#D      . Scale size of symbols to NVT duration.
#D      . Station type/shapes:
#D          + square ==> TScope
#D          + triangle ==> borehole
#D          + circle ==> other   
#D      . Color scaling to shifted delay times:
#D          + Gives PICTURE of likely AZIMUTHAL COVERAGE
#D          + Only delays for lag measurements with XCs >= cutXC
#D          + Shifted so smallest delay time == 0.0 
#D            _Using GMT 'seis'  color scale
#D            _Hot colors for low shifted times ( close to source )
#D            _Cold colors for high shifted times ( distant to source )
#D            _Stations w/ XC below cutXC plotted as GREY.
#D
    cd $datDIR
    cd DAT_"$NVTID"
    cd DAT.TRMD

    set if1 = l.STN.NT_LOCS.w.XC-RANK_LAG_DUR
  echo "Keep only STN.NC w/ OT estimates w/i dMX sec of Q1 and Q3";\
    set if0 = dat.OT.RELIABLE.Mfs_5.00; 
    set dMX = 2.50;
    set dMX = 3.00; echo "Most generally o.k. for display"
    set dMX = 2.00; echo "STANDARD: BEST to show accurate LAGs BUT less stations/ AZ coverage"
    gawk 'BEGIN{\
      dmx=sprintf("%f","'"$dMX"'"+0. );\
    }{\
      if($0 ~ /00A /){\
        q1=sprintf("%f",$7+0. );\
        med=sprintf("%f",$8+0. );\
        q3=sprintf("%f",$9+0. );\
      }else{\
      # diff=sprintf("%f",sqrt(($1-med+0.)^2) );\
      # if(diff+0. <= dmx+0.){print $0}\
        if(q1-dmx+0. <= $1+0. && $1+0. <= q3+dmx+0.){print $0}\
      }\
    }' $if0 |tee tmp.if2.$$ 
    set if2 = tmp.if2.$$
    wc $if0 $if2
    set if3 = dat.gp-select-fnl.OT.three
 echo "CENTER" 
    egrep -v '00A ' $if1 > tmp.$$
    set mnLTstn = `sort -k 2,2n tmp.$$ |sed -n '1,1p' |gawk '{print $2}'`
    set mxLTstn = `sort -k 2,2n tmp.$$ |sed -n '$,$p' |gawk '{print $2}'`
    set mnLNstn = `sort -k 3,3n tmp.$$ |sed -n '1,1p' |gawk '{print $3}'`
    set mxLNstn = `sort -k 3,3n tmp.$$ |sed -n '$,$p' |gawk '{print $3}'`
    set cLT = `echo $mxLTstn $mnLTstn |gawk '{printf("%f",$2+($1-$2)/2. )}'`
    set cLN = `echo $mxLNstn $mnLNstn |gawk '{printf("%f",$2+($1-$2)/2. )}'`
    set dLT = 1.3; echo "degrees"
    set dLN = 1.5; echo "degrees"
    set mnLT = `echo $cLT $dLT |gawk '{printf("%f",$1-$2+0. )}'`
    set mxLT = `echo $cLT $dLT |gawk '{printf("%f",$1+$2+0. )}'`
    set mnLN = `echo $cLN $dLN |gawk '{printf("%f",$1-$2+0. )}'`
    set mxLN = `echo $cLN $dLN |gawk '{printf("%f",$1+$2+0. )}'`

 echo "GRID-POINT INITIAL LOCATION"
    set C1 = 1; set C2 = 2; set C3 = 3; set WoN = 40.0
    set gpLOC = `"$utl"/mxyz2llz_flex.v3 $C1 $C2 $C3 $cLT $cLN $WoN $if3 `
  echo "Find SHFT"
    egrep -v '00A ' $if2|\
      gawk '{\
        print $9,$8,$12,$11;\
      }' |sort -k 3,3n |sed -n '1,1p' > tmp.erly.$$
    set SHFT = `cat tmp.erly.$$ |gawk '{print $3}'`
    egrep -v '00A ' $if1 |gawk '{print $1}' |sort > tmp.CHN-all.$$
    egrep -v '00A ' $if2 |gawk '{print $3}' |sort > tmp.CHN-kp.$$
    comm -23 tmp.CHN-all.$$ tmp.CHN-kp.$$ > tmp.CHN-excd.$$
    wc tmp.CHN-kp.$$ tmp.CHN-excd.$$ tmp.CHN-all.$$
    egrep -v '00A ' $if1|\
      egrep -f tmp.CHN-excd.$$ |\
      gawk '{\
        lagSC="NaN";\
        print $1,$2,$3,lagSC,$7;\
      }' |sort -n -k 4,4n |tee tmp.SN.LL.XC.DUR.$$ |head -10
    egrep -v '00A ' $if2 |\
      egrep -f tmp.CHN-kp.$$ |\
      gawk 'BEGIN{shft=sprintf("%d","'"$SHFT"'"+0 )}{\
        lagSC=sprintf("%f",($12-shft)/10.);\
        print $3,$8,$9,lagSC,$13,$11;\
      }' |sort -n -k 4,4n |tee -a tmp.SN.LL.XC.DUR.$$ 
    gawk '{\
      printf("%f %f 07 0 00 LM %s\n",($3+0.07),$2,$1 );\
    }' tmp.SN.LL.XC.DUR.$$  |tee txtFN1.$$ |head -3
    wc tmp.CHN-kp.$$ dat.OT.RELIABLE.Mfs_0.50 dat.OT.RELIABLE.Mfs_1.00 
    "$utl"/map.STNs_color-size_LAGs  $mnLT $mxLT $mnLN $mxLN $cLT $cLN \
                                     tmp.SN.LL.XC.DUR.$$ txtFN1.$$ "$gpLOC"
    mv myp2 myp.MAP_LAGs.ps
 

      endif
          if ( "$vuPLOTs" == "Y" ) then
            cd $vuPLTdir
            gv  myp.MAP_LAGs.ps
          endif
#DE===:: OPTIONAL ::
#DE===:: OPTIONAL ::


echo "B4444"


#DS===:: OPTIONAL ::
#DS===:: OPTIONAL ::
      if ( "$mkPLOTs" == "Y" ) then


#D     --------------------------------------------------------------------------
#D     + MOVEOUT SUITE of vlps and wfs :  NORMALIZED
#D       !!! AT-ORDER !!!
#D         {CONSIDER: (TRUSTED-lags-moveout; BLACK)  REJECT: (GRAY) }
#D     --------------------------------------------------------------------------
#D      . Trims the first and last 4 minutes off 
#D      . IMPORTANT:
#D        + Consider (black) are order by their arrival-times
#D            from earliest/BOTTOM (black) to latest/TOP    (black) 
#D        + REJECT (gray) are order by their arrival-times
#D            from earliest/TOP    (gray)  to latest/BOTTOM (gray) ..
#D
#D      (OTPT:  myp.CONSIDER-REJECT_AT-ORDER.ps
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

     echo "PREP"
        set inclERM = "Y"; echo "Include the PSERM: yes"
        set inclERM = "N"; echo "Include the PSERM:  no"
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat.*_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat.*_detect-INFO`
        set sT = `caldate -- $nvtSTRT -1M`
        set eT = `caldate -- $nvtEND  +1M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set vlpINFO = l.ranked.INFO
        set wfINFO = l.ranked.wfFNs
     echo "Re-rank by AT-MOVEOUT for TRUSTED only STN.NC w/ OT estimates w/i dMX sec of Q1 and Q3";\
        set if0 = dat.OT.RELIABLE.Mfs_5.00; 
        set dMX = 2.00; echo "Black"
        set dMX = 5.00; echo "Black"
        set dMX = 4.00; echo "Black**"
        gawk 'BEGIN{\
          dmx=sprintf("%f","'"$dMX"'"+0. );\
        }{\
          if($0 ~ /00A /){\
            q1=sprintf("%f",$7+0. );\
            med=sprintf("%f",$8+0. );\
            q3=sprintf("%f",$9+0. );\
          }else{\
          # diff=sprintf("%f",sqrt(($1-med+0.)^2) );\
          # if(diff+0. <= dmx+0.){print $0}\
            if(q1-dmx+0. <= $1+0. && $1+0. <= q3+dmx+0.){print " "$3"."}\
          }\
        }' $if0 > tmp.stn-trust.$$
        egrep -f tmp.stn-trust.$$ $vlpINFO |\
          sort -k 5,5n |\
          gawk 'BEGIN{i=0+0}{\
            $1=NR;\
            print $0;\
          }' > tmp.vlpINFO_blck.$$

     echo "VLPS-BLACK: CONSIDER-RANKED LIST ## NORMALIZED"
        gawk 'BEGIN{i=0+0}{\
          i=i+1;\
          fn[i]=sprintf("%s",$3 );\
        }END{\
          for(j=1;j<=i;j++){\
            print fn[j];\
          }\
        }' tmp.vlpINFO_blck.$$ > tmp.lst-rnkd.vlps.$$
        /bin/rm pltdat.SUITE-BLACK.vlps;  touch pltdat.SUITE-BLACK.vlps
        set Ntrc = `wc $vlpINFO |gawk '{print $1}'` 
        set NtrcKP = `wc tmp.lst-rnkd.vlps.$$ |gawk '{print $1}'` 
        set iTRC = `echo $NtrcKP |gawk '{printf("%d",$1+1 )}'`
        foreach if (` cat tmp.lst-rnkd.vlps.$$ |sed -n '1,$p' `)
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(3000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-3000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1 )}'`
          gawk 'BEGIN{\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(2400+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-2400){\
            printf("%lf\n",(-1.5*($1-shft)/rng)+(itrc+0.) ) ;\
     }\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE-BLACK.vlps
        end

     echo "VLPS-GRAY: REJECT LIST ## NORMALIZED"
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8;\
        }' tmp.lst-rnkd.vlps.$$ > tmp.fgrp.$$ 
        egrep -vf tmp.fgrp.$$ $vlpINFO |\
          sort -k 5,5nr |gawk '{print $3}' > tmp.lst-rjct.vlps.$$
        /bin/rm pltdat.SUITE-GRAY.vlps;  touch pltdat.SUITE-GRAY.vlps
        set Ntrc = `wc $vlpINFO |gawk '{print $1}'` 
        set iTRC = `echo $Ntrc |gawk '{printf("%d",$1+1 )}'`
        foreach if (` cat tmp.lst-rjct.vlps.$$ |sed -n '1,$p' `)
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(3000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-3000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1 )}'`
          gawk 'BEGIN{\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(2400+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-2400){\
            printf("%lf\n",(-1.5*($1-shft)/rng)+(itrc+0.) ) ;\
     }\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE-GRAY.vlps
        end

     echo "WFs BLACK: CONSIDER-RANKED LIST ## NORMALIZED"
        set DECIMATE = 2
        set DECIMATE = 5
        set DECIMATE = 10
        set SPSwf = 20; 
        set SPSwfPLT = `echo $SPSwf $DECIMATE |gawk '{printf("%d",int(($1/$2)+0.5) )}'`
        gawk 'BEGIN{i=0+0}{\
          i=i+1;\
          gsub(".trmd",".ascii");\
          fn[i]=sprintf("%s",$1 );\
        }END{\
          for(j=i;j>0;j--){\
            print fn[j];\
          }\
        }' $wfINFO > tmp.lst-init.wfs.$$
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8,"ascii";\
        }' tmp.lst-rnkd.vlps.$$ > tmp.lst-rnkd.wfs.$$
        /bin/rm pltdat.SUITE-BLACK.wfs;  touch pltdat.SUITE-BLACK.wfs
        set Ntrc = `wc $wfINFO |gawk '{print $1}'` 
        set NtrcKP = `wc tmp.lst-rnkd.wfs.$$ |gawk '{print $1}'`
        set iTRC = `echo $NtrcKP |gawk '{printf("%d",$1+1  )}'`
        foreach if (` cat tmp.lst-rnkd.wfs.$$ |sed -n '1,$p' `)
          set DC = `$utl/mav $if |gawk '{printf("%lf\n",$6+0. )}'`
          gawk '{printf("%lf\n",($1-"'"$DC"'")+0. )}' $if \
            > tmpx.$$
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(6000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-6000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1  )}'`
          gawk 'BEGIN{\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(4800+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-4800){\
            if( (NR % decim) == 1+0 ){\
              printf("%lf\n",(-0.7*($1)/rng)+(itrc-0.5) ) ;\
            }\
     }\
          }END{\
            print "sss";\
          }' tmpx.$$ >> pltdat.SUITE-BLACK.wfs
        end

     echo "WFs GRAY: REJECT LIST ## NORMALIZED"
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8,"ascii";\
        }' tmp.lst-rjct.vlps.$$ > tmp.lst-rjct.wfs.$$
        /bin/rm pltdat.SUITE-GRAY.wfs;  touch pltdat.SUITE-GRAY.wfs
        set Ntrc = `wc $wfINFO |gawk '{print $1}'` 
        set iTRC = `echo $Ntrc |gawk '{printf("%d",$1+1 )}'`
        foreach if (` cat tmp.lst-rjct.wfs.$$ |sed -n '1,$p' `)
          set DC = `$utl/mav $if |gawk '{printf("%lf\n",$6+0. )}'`
          gawk '{printf("%lf\n",($1-"'"$DC"'")+0. )}' $if \
          > tmpx.$$
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(6000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-6000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1  )}'`
          gawk 'BEGIN{\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(4800+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-4800){\
            if( (NR % decim) == 1+0 ){\
              printf("%lf\n",(-0.7*($1)/rng)+(itrc-0.5) ) ;\
            }\
     }\
          }END{\
            print "sss";\
          }' tmpx.$$ >> pltdat.SUITE-GRAY.wfs
        end
        "$utl"/mGplt.CONSIDER-REJECT    $inclERM  $Ntrc  $pLEN  $SPSwfPLT \
                                        pltdat.SUITE-BLACK.vlps pltdat.SUITE-GRAY.vlps \
                                        pltdat.SUITE-BLACK.wfs  pltdat.SUITE-GRAY.wfs
         mv myp2 myp.CONSIDER-REJECT_AT-ORDER.ps

#DSS--Quick Just VLPs
#D        "$utl"/mGplt.CONSIDER-REJECT    $inclERM  $Ntrc  $pLEN  $SPSwfPLT \
#D                                        pltdat.SUITE-BLACK.vlps pltdat.SUITE-GRAY.vlps \
#D                                        pltdat.SUITE-BLACK.vlps pltdat.SUITE-GRAY.vlps  
#D        ]]]
#DEE--Quick Just VLPs



#D     --------------------------------------------------------------------------
#D     + MOVEOUT SUITE of vlps and wfs :  NORMALIZED
#D       !!! SRC-STN DISTANCE ORDER !!!
#D         {CONSIDER: (TRUSTED-lags-moveout; BLACK)  REJECT: (GRAY) }
#D     --------------------------------------------------------------------------
#D      . Trims the first and last 4 minutes off 
#D      . IMPORTANT:
#D        + Consider (black) are order by their distance from gp source location
#D            from nearest/BOTTOM (black) to furthest/TOP    (black) 
#D        + REJECT (gray) are order by their distance from gp source location
#D            from nearest/TOP    (gray)  to furthest/BOTTOM (gray) ..
#D
#D      (OTPT:  l.ranked.INFO_gp-stn.dist
#D      (OTPT:  myp.CONSIDER-REJECT_DIST-ORDER.ps
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

     echo "PREP"
        set inclERM = "Y"; echo "Include the PSERM: yes"
        set inclERM = "N"; echo "Include the PSERM:  no"
        set nvtSTRT = `gawk '{printf("%s",$1 )}' cat.*_detect-INFO`
        set nvtEND  = `gawk '{printf("%s",$3 )}' cat.*_detect-INFO`
        set sT = `caldate -- $nvtSTRT -1M`
        set eT = `caldate -- $nvtEND  +1M`
        set pLEN = \
  `caldate -f %M_%S_%F -d $eT $sT |gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set vlpINFO = l.ranked.INFO
        set wfINFO = l.ranked.wfFNs
        set nwFN =   l.ranked.INFO_gp-stn.dist
    echo "Add station DISTANCE to gp-source to file: _vlpINFO_"
        set stnFN = l.STN.NT_LOCS_XC-RANK_LAG_DUR.wXYD-LCL
        set gpFN = dat.gp-select-fnl.OT.three 
        gawk 'BEGIN{i=j=k=I=J=K=U=0+0}{\
        }{\
          if(FILENAME == "'"$gpFN"'"){\
            split($0,a);\
            x=sprintf("%f", a[1] );\
            y=sprintf("%f", a[2] );\
            d=sprintf("%f", a[3] );\
          }\
          if(FILENAME == "'"$stnFN"'"){\
            i=i+1;\
            stn[i]=sprintf("%s", $0 );\
          }\
          if(FILENAME == "'"$vlpINFO"'"){\
            j=j+1;\
            vlp[j]=sprintf("%s", $0 );\
          }\
        }END{\
          for(I=1;I<=i;I++){\
            split(stn[I],a);\
            STN=sprintf("%s", a[4] );\
            sx=sprintf("%f", a[1] );\
            sy=sprintf("%f", a[2] );\
            sd=sprintf("%f", a[3] );\
            dx=sprintf("%f", sx-x );\
            dy=sprintf("%f", sy-y );\
            dd=sprintf("%f", sd-d );\
            sep=sprintf("%f",sqrt( (dx^2)+(dy^2)+(dd^2) ) );\
            sep_stn[I] = sprintf("%f %s",sep,STN );\
          }\
          for(U=1;U<=i;U++){\
            split(sep_stn[U],a);\
            sep=sprintf("%f", a[1] );\
            STN=sprintf("%s", a[2] );\
            for(J=1;J<=j;J++){\
              if(vlp[J] ~ STN){\
                print vlp[J],sep;\
              }\
            }\
          }\
        }' $gpFN $stnFN $vlpINFO  |tee $nwFN

  echo "Re-rank by DISTANCE-MOVEOUT for TRUSTED only STN.NC w/ OT estimates w/i dMX sec of Q1 and Q3";\
        set if0 = dat.OT.RELIABLE.Mfs_5.00; 
        set dMX = 2.00; echo "Black"
        set dMX = 5.00; echo "Black"
        set dMX = 4.00; echo "Black**"
        gawk 'BEGIN{\
          dmx=sprintf("%f","'"$dMX"'"+0. );\
        }{\
          if($0 ~ /00A /){\
            q1=sprintf("%f",$7+0. );\
            med=sprintf("%f",$8+0. );\
            q3=sprintf("%f",$9+0. );\
          }else{\
          # diff=sprintf("%f",sqrt(($1-med+0.)^2) );\
          # if(diff+0. <= dmx+0.){print $0}\
            if(q1-dmx+0. <= $1+0. && $1+0. <= q3+dmx+0.){print " "$3"."}\
          }\
        }' $if0 > tmp.stn-trust.$$
        egrep -f tmp.stn-trust.$$ $nwFN |\
          sort -k 7,7n |\
          gawk 'BEGIN{i=0+0}{\
            $1=NR;\
            print $0;\
          }' > tmp.vlpINFO_blck.$$

     echo "VLPS-BLACK: CONSIDER-RANKED LIST ## NORMALIZED"
        gawk 'BEGIN{i=0+0}{\
          i=i+1;\
          fn[i]=sprintf("%s",$3 );\
        }END{\
          for(j=1;j<=i;j++){\
            print fn[j];\
          }\
        }' tmp.vlpINFO_blck.$$ > tmp.lst-rnkd.vlps.$$
        /bin/rm pltdat.SUITE-BLACK.vlps;  touch pltdat.SUITE-BLACK.vlps
        set Ntrc = `wc $nwFN |gawk '{print $1}'` 
        set NtrcKP = `wc tmp.lst-rnkd.vlps.$$ |gawk '{print $1}'` 
        set iTRC = `echo $NtrcKP |gawk '{printf("%d",$1+1 )}'`
        foreach if (` cat tmp.lst-rnkd.vlps.$$ |sed -n '1,$p' `)
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(3000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-3000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1 )}'`
          gawk 'BEGIN{\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(2400+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-2400){\
            printf("%lf\n",(-1.5*($1-shft)/rng)+(itrc+0.) ) ;\
     }\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE-BLACK.vlps
        end

     echo "VLPS-GRAY: REJECT LIST ## NORMALIZED"
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8;\
        }' tmp.lst-rnkd.vlps.$$ > tmp.fgrp.$$ 
        egrep -vf tmp.fgrp.$$ $nwFN |\
          sort -k 7,7nr |gawk '{print $3}' > tmp.lst-rjct.vlps.$$
        /bin/rm pltdat.SUITE-GRAY.vlps;  touch pltdat.SUITE-GRAY.vlps
        set Ntrc = `wc $nwFN |gawk '{print $1}'` 
        set iTRC = `echo $Ntrc |gawk '{printf("%d",$1+1 )}'`
        foreach if (` cat tmp.lst-rjct.vlps.$$ |sed -n '1,$p' `)
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(3000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-3000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1 )}'`
          gawk 'BEGIN{\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(2400+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-2400){\
            printf("%lf\n",(-1.5*($1-shft)/rng)+(itrc+0.) ) ;\
     }\
          }END{\
            print "sss";\
          }' $if >> pltdat.SUITE-GRAY.vlps
        end

     echo "WFs BLACK: CONSIDER-RANKED LIST ## NORMALIZED"
        set DECIMATE = 2
        set DECIMATE = 5
        set DECIMATE = 10
        set SPSwf = 20; 
        set SPSwfPLT = `echo $SPSwf $DECIMATE |gawk '{printf("%d",int(($1/$2)+0.5) )}'`
        gawk 'BEGIN{i=0+0}{\
          i=i+1;\
          gsub(".trmd",".ascii");\
          fn[i]=sprintf("%s",$1 );\
        }END{\
          for(j=i;j>0;j--){\
            print fn[j];\
          }\
        }' $wfINFO > tmp.lst-init.wfs.$$
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8,"ascii";\
        }' tmp.lst-rnkd.vlps.$$ > tmp.lst-rnkd.wfs.$$
        /bin/rm pltdat.SUITE-BLACK.wfs;  touch pltdat.SUITE-BLACK.wfs
        set Ntrc = `wc $wfINFO |gawk '{print $1}'` 
        set NtrcKP = `wc tmp.lst-rnkd.wfs.$$ |gawk '{print $1}'`
        set iTRC = `echo $NtrcKP |gawk '{printf("%d",$1+1  )}'`
        foreach if (` cat tmp.lst-rnkd.wfs.$$ |sed -n '1,$p' `)
          set DC = `$utl/mav $if |gawk '{printf("%lf\n",$6+0. )}'`
          gawk '{printf("%lf\n",($1-"'"$DC"'")+0. )}' $if \
            > tmpx.$$
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(6000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-6000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1  )}'`
          gawk 'BEGIN{\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(4800+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-4800){\
            if( (NR % decim) == 1+0 ){\
              printf("%lf\n",(-0.7*($1)/rng)+(itrc-0.5) ) ;\
            }\
     }\
          }END{\
            print "sss";\
          }' tmpx.$$ >> pltdat.SUITE-BLACK.wfs
        end

     echo "WFs GRAY: REJECT LIST ## NORMALIZED"
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8,"ascii";\
        }' tmp.lst-rjct.vlps.$$ > tmp.lst-rjct.wfs.$$
        /bin/rm pltdat.SUITE-GRAY.wfs;  touch pltdat.SUITE-GRAY.wfs
        set Ntrc = `wc $wfINFO |gawk '{print $1}'` 
        set iTRC = `echo $Ntrc |gawk '{printf("%d",$1+1 )}'`
        foreach if (` cat tmp.lst-rjct.wfs.$$ |sed -n '1,$p' `)
          set DC = `$utl/mav $if |gawk '{printf("%lf\n",$6+0. )}'`
          gawk '{printf("%lf\n",($1-"'"$DC"'")+0. )}' $if \
          > tmpx.$$
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(6000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-6000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iTRC = `echo $iTRC |gawk '{printf("%d",$1-1  )}'`
          gawk 'BEGIN{\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            itrc=sprintf("%f","'"$iTRC"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(4800+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-4800){\
            if( (NR % decim) == 1+0 ){\
              printf("%lf\n",(-0.7*($1)/rng)+(itrc-0.5) ) ;\
            }\
     }\
          }END{\
            print "sss";\
          }' tmpx.$$ >> pltdat.SUITE-GRAY.wfs
        end
        "$utl"/mGplt.CONSIDER-REJECT    $inclERM  $Ntrc  $pLEN  $SPSwfPLT \
                                        pltdat.SUITE-BLACK.vlps pltdat.SUITE-GRAY.vlps \
                                        pltdat.SUITE-BLACK.wfs  pltdat.SUITE-GRAY.wfs
         mv myp2 myp.CONSIDER-REJECT_DIST-ORDER.ps


#D     --------------------------------------------------------------------------
#D     + ATvsDIST MOVEOUT SUITE of vlps and wfs :  NORMALIZED
#D       !!! SRC-STN DISTANCE ORDER !!!
#D         { CONSIDER: (TRUSTED-lags-moveout; BLACK)  REJECT: (GRAY) }
#D     --------------------------------------------------------------------------
#D     PREP-1:
#D      - Find LRGamp portion of vlp_ts: Portion of psERM w/ strong high-low signal contrast
#D           = Using Kurtosis, I keep getting results where ~ the peak is at one
#D               end of the chosen window. I need the peak more in the center.
#D           = I can't simply use a summ of vlp the values since I am also interested in
#D               a range of values to enhance XC. 
#D           = So have implemented a MAD based selection for n10 to n90 data.
#D           . PYTHON code
#D           . Use Smoothed psERM
#D           . Look for swlenM portion of psERM with highest signal as measured by:
#D              + MAD (mean average deviation) w/i p10 to p90 (to reduce quake effects)
#D                --> more high-low contrast for XCs
#D           . Start search 15 sec before through 15 sec after nvt detection
#D              + that is 1st sample of swlenM starts 15 sec before
#D                and  last sample of swlenM ends 15 sec after detection period
#D           . If nvt duration < swlenMmx0, use: nvt duration
#D           . vlp_ts starts 5 min before tremor starts (per trimming above)
#D           . stp interval is 10 smp for search (set internally in code, could be increased later for speed)
#D      (OTPT: dat.LRGampINFO )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set passtyp = ".normal2"
        set infoFN = l.BEST.ptil"$passtyp"
        set catFN = ` ls cat.*_detect-INFO `
        set ptil = `cat "$infoFN" |gawk '{split($4,a,"_");print substr(a[2],1,5)}'`
        set if = dat.PSERM_"$ptil"_medSMOOTH
        set SPSvlp = 10
        set pmSMP = 150; echo "(15 sec at 10 sps)"
        set swlenMmx0 = 03.0; echo "minutes For above?"
        set swlenMmx0 = 01.0; echo "minutes For PLOTTING"
        set nvtDUR = ` cat $catFN |gawk '{printf("%f",$6+0. ) }' `
        set swlenMmx = `echo $swlenMmx0 $nvtDUR |\
          gawk '{if($1+0. > $2+0.){printf("%f",$2+0.)}else{printf("%f",$1+0.)}}' `
        set swlen = `echo "$swlenMmx 60 $SPSvlp" |gawk '{printf("%d",$1*$2*$3 )}'`
        set nvtSTRT = `gawk '{printf("%s",$1 )}' $catFN `
        set nvtEND  = `gawk '{printf("%s",$3 )}' $catFN `
        set dM = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$1)}'`
        set dS = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$2)}'`
        set dF = `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |sed 's/\_/ /g' |gawk '{printf("%d",$3)}'`
        set durM = `echo "$dM $dS $dF" |gawk '{printf("%f",($1+(($2+($3/10000))/60.)) )}'`
        set durSMP = \
          `echo "$dM $dS $dF $SPSvlp" |gawk '{printf("%d",($1*60*$4)+($2*$4)+(($3/10000)*$4) )}'`
        set srchS = `echo "5. 60. $SPSvlp $pmSMP" |gawk '{printf("%d",($1*$2*$3)-$4 )}'`
        set srchE = `echo "$srchS $durSMP $pmSMP" |gawk '{printf("%d",($1+$2)+(2.*$3) )}'`
        echo "$srchS $srchE $swlen $SPSvlp $if"
        $spy2; echo "source shared libraries for PYTHON 2"
        "$utl"/mLRGvlp-search_mad.py $srchS $srchE $swlen $SPSvlp $if |\
          sort -k 6,6nr |sed -n '1,1p' |\
          gawk 'BEGIN{\
            print "00A segDUR(min) minS   minE  smpS smpE kurtosis      MAD          FN" ;\
          }{\
           printf("   %+11s %s %s %s %s %s %s   %s  %s\n", \
             "'"$swlenMmx"'",$1,$2,$3,$4,$5,$6,$7,"'"$if"'" );\
          }' | tee dat.LRGampINFO
          

#D     PREP-2:
#D      - 0) Get the nvt start time (=nvtSTRT)
#D      - 1) Determine duration to be plotted (=durM)
#D      - 2) Determine and SET the start and end time of plots (sT, eT(=sT+durM))
#D             (i.e., start of nvt-trigger from catFN
#D               minus the estimated ot shift relative to the
#D               ERM--from the gp search results: dat.gp-select-fnl.OT.three )
#D           So effectively, the plot starts at the estimated origin time of the NVT. 
#D             (i.e., sT == OT)
#D      - 3) Select TRUSTED (OT estimates w/i dMX sec of Q1 and Q3) STN.NC and associated
#D               OT estimates.
#D      (OTPT: set nvtSTRT )
#D      (OTPT: set durM )
#D      (OTPT: set sT )
#D      (OTPT: set eT )
#D      (OTPT: plt.vlpINFO_trust.$$ )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set vlpINFO = l.ranked.INFO
        set wfINFO  = l.ranked.wfFNs
        set dstFN   = l.ranked.INFO_gp-stn.dist
        set catFN = ` ls cat.*_detect-INFO `
        set lvotFN = dat.gp-select-fnl.OT.three
        set nvtSTRT = ` gawk '{printf("%s",$1 )}' $catFN `
        set nvtEND  = ` gawk '{printf("%s",$3 )}' $catFN `
        set durM = 5; echo "Plot _durM_ of ts"
        set durM = \
          `caldate -f %M_%S_%F -d $nvtEND $nvtSTRT |\
             gawk '{split($0,a,"_");printf("%d\n",int( (1.0+a[1]+(a[2]+(a[3]/10000.))/60.) ) )}'`;\
             echo "Plot entire duration of nvt_ts rounded up to nearest minute. "
        set lvotSTR = ` cat $lvotFN `
        echo "$lvotSTR" |\
          gawk 'BEGIN{nvtstrt=sprintf("%s","'"$nvtSTRT"'" )}{\
            ot=sprintf("%f",$14+0. );\
            otS=sprintf("%02d",int(ot+0.) );\
            otF=sprintf("%04d",int( (ot-otS)*10000-0.5 ) );\
            printf("%s %02dS %04dF\n",nvtstrt,otS,otF ) >"/dev/tty";\
            if(otS+0 != 0+0 && otF != 0+0){\
              printf("caldate -- %s %02dS %04dF\n",nvtstrt,otS,otF );\
            }\
            if(otS+0 != 0+0 && otF == 0+0){\
              printf("caldate -- %s %02dS\n",nvtstrt,otS );\
            }\
            if(otS+0 == 0+0 && otF != 0+0){\
              printf("caldate -- %s %04dF\n",nvtstrt,otF );\
            }\
            if(otS+0 == 0+0 && otF == 0+0){\
              printf("caldate -- %s\n",nvtstrt);\
            }\
          }' > tmp.exe.$$
          chmod 700 tmp.exe.$$
        set sT = ` tmp.exe.$$ `
        set eT = `caldate -- $sT  +"$durM"M`
    echo "Select TRUSTED only STN.NC w/ OT estimates w/i dMX sec of Q1 and Q3";\
        set if0 = dat.OT.RELIABLE.Mfs_5.00; 
        set dMX = 5.00; echo "Black"
        set dMX = 4.00; echo "Black** for Consideration ?"
        set dMX = 2.00; echo "Black for PLOTTING"
        gawk 'BEGIN{\
          dmx=sprintf("%f","'"$dMX"'"+0. );\
        }{\
          if($0 ~ /00A /){\
            q1=sprintf("%f",$7+0. );\
            med=sprintf("%f",$8+0. );\
            q3=sprintf("%f",$9+0. );\
          }else{\
          # diff=sprintf("%f",sqrt(($1-med+0.)^2) );\
          # if(diff+0. <= dmx+0.){print $0}\
            if(q1-dmx+0. <= $1+0. && $1+0. <= q3+dmx+0.){print " "$3"."}\
          }\
        }' $if0 > plt.stn-trust.$$
        egrep -f plt.stn-trust.$$ $dstFN |\
          sort -k 7,7n |\
          gawk 'BEGIN{i=0+0}{\
            $1=NR;\
            print $0;\
          }' |tee plt.vlpINFO_trust.$$


#D     PLOTS: 
#D        . Orignial vlps and wfs start 5 minutes before the trigger time
#D        . sT == OT
#D        . Plots will start at OT (=sT above) 
#D        . Plots duration will == entire nvt_ts duration rounded up to nearest minute. 
#D        . 4-separate plots.
#D          1) Consider vlps
#D          2) Consider wfs
#D          3) Rejected vlps
#D          4) Rejected wfs
#D      ## ATvsDIST CONSIDER VLPS ## NORMALIZED
#D        . Original vlps extend +/- 5 min before and after NVT trigger (+/-3000 smps at 10 sps)
#D        . Normalization is quick and dirty based on NVT trigger duration period 
#D            (i.e., 3000smps after start of record to 3000smps before end of record)
#D        . However, plot start will be: { (3000smps) - (OT_shift from column 14 of: lvotFN) }
#D        . So plot starts at OT (=sT above) 
#D        . AND plot duration will == entire nvt_ts duration rounded up to nearest minute. 
#D      (OTPT:  myp.AT-DIST_CONSIDER_vlps.ps )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set dstFN   = l.ranked.INFO_gp-stn.dist
        set LGampFN = dat.LRGampINFO
        set pLEN = \
          `caldate -f %M_%S_%F -d $eT $sT |\
          gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set lvotFN = dat.gp-select-fnl.OT.three
        set Vest = ` cat $lvotFN |gawk '{printf("%f",$6+0.)}' `
        set vlpSPS = 10
        set durMsmp = ` echo $durM $vlpSPS |gawk '{printf("%d",int( $1*60.*"'"$vlpSPS"'" ) )}' `
        set shftOTsmp = ` gawk '{printf("%d\n", int(($14+0.)*"'"$vlpSPS"'")  )}' $lvotFN `
        gawk 'BEGIN{i=0+0}{\
          i=i+1;\
          fn[i]=sprintf("%s",$3 );\
        }END{\
          for(j=i;j>=1;j--){\
            print fn[j];\
          }\
        }' plt.vlpINFO_trust.$$ > tmp.lst-rnkd.vlps.$$
        /bin/rm pltdat.CONSIDER.vlps;  touch pltdat.CONSIDER.vlps
        set Smax = ` sort -k 7,7n  $dstFN |sed -n '$,$p' |gawk '{print $7+10.}'` 
        foreach if (` cat tmp.lst-rnkd.vlps.$$ |sed -n '1,$p' `)
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(3000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-3000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N15 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.15)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V15 = `sed -n ''"$N15"','"$N15"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iS = `egrep "$if" plt.vlpINFO_trust.$$ |gawk '{printf("%f",$7+0.)}'`
          gawk 'BEGIN{\
            is=sprintf("%f","'"$iS"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
            shft_ot=sprintf("%d","'"$shftOTsmp"'"+0 );\
          }{\
     if(3000+shft_ot <= NR+0 && NR+0 <= 3000+shft_ot+"'"$durMsmp"'"+0 ){\
            printf("%lf %f\n",(5.5*($1-shft)/rng),(is+0.) ) ;\
     }\
          }END{\
            print "sss";\
          }' $if >> pltdat.CONSIDER.vlps
        end
        set addSHFT = -3.5; echo "For touch-ups only"
        set addSHFT = 0.0;  echo "STANDARD"
        set Vshft = 0.0;echo "(min.)"
        set Vshft = ` egrep -v '00A ' $LGampFN |gawk '{printf("%f",$2-5.0+"'"$addSHFT"'" )}' `
        "$utl"/mGplt.DISTvsAT.vlps  $Smax $pLEN $Vest $Vshft pltdat.CONSIDER.vlps
        mv myp2 myp.AT-DIST_CONSIDER_vlps.ps


#D      ## ATvsDIST REJECT VLPS ## NORMALIZED
#D        . Original vlps extend +/- 5 min before and after NVT trigger (+/-3000 smps at 10 sps)
#D        . Normalization is quick and dirty based on NVT trigger duration period 
#D            (i.e., 3000smps after start of record to 3000smps before end of record)
#D        . However, plot start will be: { (3000smps) - (OT_shift from column 14 of: lvotFN) }
#D        . So plot starts at OT (=sT above) 
#D        . AND plot duration will == entire nvt_ts duration rounded up to nearest minute. 
#D      (OTPT:  myp.AT-DIST_REJECT_vlps.ps )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set dstFN   = l.ranked.INFO_gp-stn.dist
        set LGampFN = dat.LRGampINFO
        set pLEN = \
          `caldate -f %M_%S_%F -d $eT $sT |\
          gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set lvotFN = dat.gp-select-fnl.OT.three
        set dstINFO = l.ranked.INFO_gp-stn.dist
        set Vest = ` cat $lvotFN |gawk '{printf("%f",$6+0.)}' `
        set vlpSPS = 10
        set durMsmp = ` echo $durM $vlpSPS |gawk '{printf("%d",int( $1*60.*"'"$vlpSPS"'" ) )}' `
        set shftOTsmp = ` gawk '{printf("%d\n", int(($14+0.)*"'"$vlpSPS"'")  )}' $lvotFN `
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8;\
        }' tmp.lst-rnkd.vlps.$$ > tmp.fgrp.$$ 
        egrep -vf tmp.fgrp.$$ $dstINFO |\
          sort -k 7,7nr |gawk '{print $0}' > plt.vlpINFO_rjct.$$
        gawk 'BEGIN{i=0+0}{\
          i=i+1;\
          fn[i]=sprintf("%s",$3 );\
        }END{\
          for(j=i;j>=1;j--){\
            print fn[j];\
          }\
        }' plt.vlpINFO_rjct.$$ > plt.lst-rnkd-rjct.vlps.$$
        /bin/rm pltdat.REJECT.vlps;  touch pltdat.REJECT.vlps
        set Smax = ` sort -k 7,7n  $dstFN |sed -n '$,$p' |gawk '{print $7+10.}'` 
        foreach if (` cat plt.lst-rnkd-rjct.vlps.$$ |sed -n '1,$p' `)
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(3000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-3000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N15 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.15)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V15 = `sed -n ''"$N15"','"$N15"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iS = `egrep "$if" plt.vlpINFO_rjct.$$ |gawk '{printf("%f",$7+0.)}'`
          gawk 'BEGIN{\
            is=sprintf("%f","'"$iS"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
          }{\
     if(3000+shft_ot <= NR+0 && NR+0 <= 3000+shft_ot+"'"$durMsmp"'"+0 ){\
            printf("%lf %f\n",(5.5*($1-shft)/rng),(is+0.) ) ;\
     }\
          }END{\
            print "sss";\
          }' $if >> pltdat.REJECT.vlps
        end
        set addSHFT = -3.5; echo "For touch-ups only"
        set addSHFT = 0.0;  echo "STANDARD"
        set Vshft = 0.0;echo "(min.)"
        set Vshft = ` egrep -v '00A ' $LGampFN |gawk '{printf("%f",$2-5.0+"'"$addSHFT"'" )}' `
        "$utl"/mGplt.DISTvsAT.vlps  $Smax $pLEN $Vest $Vshft pltdat.REJECT.vlps
        mv myp2 myp.AT-DIST_REJECT_vlps.ps


#D      ## ATvsDIST CONSIDER wfs ## NORMALIZED
#D        . Original wfs extend +/- 5 min before and after NVT trigger (+/-6000 smps at 20 sps)
#D        . Normalization is quick and dirty based on NVT trigger duration period
#D            (i.e., 6000smps after start of record to 6000smps before end of record)
#D        . However, plot start will be: { (6000smps) - (OT_shift from column 14 of: lvotFN) }
#D        . So plot starts at OT (=sT above)
#D        . AND plot duration will == entire nvt_ts duration rounded up to nearest minute.
#D      (OTPT:  myp.AT-DIST_CONSIDER_wfs.ps )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set dstFN   = l.ranked.INFO_gp-stn.dist
        set LGampFN = dat.LRGampINFO
        set pLEN = 10.0
        set pLEN = \
          `caldate -f %M_%S_%F -d $eT $sT |\
          gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set lvotFN = dat.gp-select-fnl.OT.three
        set Vest = ` cat $lvotFN |gawk '{printf("%f",$6+0.)}' `
        set wfSPS = 20; 
     echo "WFs CONSIDER-RANKED LIST ## NORMALIZED"
        set DECIMATE = 10
        set DECIMATE = 2
        set DECIMATE = 5
        set wfSPSplt = `echo $wfSPS $DECIMATE |gawk '{printf("%d",int(($1/$2)+0.5) )}'`
        set durMsmp = ` echo $durM $wfSPS |gawk '{printf("%d",int( $1*60.*"'"$wfSPS"'" ) )}' `
        set shftOTsmp = ` gawk '{printf("%d\n", int(($14+0.)*"'"$wfSPS"'")  )}' $lvotFN `
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8,"ascii";\
        }' tmp.lst-rnkd.vlps.$$ > tmp.lst-rnkd.wfs.$$
        set Smax = ` sort -k 7,7n  $dstFN |sed -n '$,$p' |gawk '{print $7+10.}'`
        /bin/rm pltdat.CONSIDER.wfs;  touch pltdat.CONSIDER.wfs
        foreach if (` cat tmp.lst-rnkd.wfs.$$ |sed -n '1,$p' `)
          set if_shrt = ` echo $if |sed 's/ascii//' `
          set DC = `$utl/mav $if |gawk '{printf("%lf\n",$6+0. )}'`
          gawk '{printf("%lf\n",($1-"'"$DC"'")+0. )}' $if \
            > tmpx.$$
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(6000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-6000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N15 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.15)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V15 = `sed -n ''"$N15"','"$N15"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iS = `egrep "$if_shrt" $dstFN |gawk '{printf("%f",$7+0.)}'`
          gawk 'BEGIN{\
            is=sprintf("%f","'"$iS"'"+0. );\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
            shft_ot=sprintf("%d","'"$shftOTsmp"'"+0 );\
          }{\
     if(6000+shft_ot <= NR+0 && NR+0 <= 6000+shft_ot+"'"$durMsmp"'"+0 ){\
            if( (NR % decim) == 1+0 ){\
              printf("%lf %f\n",(-0.7*($1)/rng),(is+0.) ) ;\
            }\
     }\
          }END{\
            print "sss";\
          }' tmpx.$$ >> pltdat.CONSIDER.wfs
        end
        set addSHFT = -3.5; echo "For touch-ups only"
        set addSHFT = 0.0;  echo "STANDARD"
        set Vshft = 0.0;echo "(min.)"
        set Vshft = ` egrep -v '00A ' $LGampFN |gawk '{printf("%f",$2-5.0+"'"$addSHFT"'" )}' `
        "$utl"/mGplt.DISTvsAT.wfs  $Smax $pLEN $Vest $Vshft $DECIMATE pltdat.CONSIDER.wfs
        mv myp2 myp.AT-DIST_CONSIDER_wfs.ps


#D      ## ATvsDIST REJECT wfs ## NORMALIZED
#D        . Original wfs extend +/- 5 min before and after NVT trigger (+/-6000 smps at 20 sps)
#D        . Normalization is quick and dirty based on NVT trigger duration period
#D            (i.e., 6000smps after start of record to 6000smps before end of record)
#D        . However, plot start will be: { (6000smps) - (OT_shift from column 14 of: lvotFN) }
#D        . So plot starts at OT (=sT above)
#D        . AND plot duration will == entire nvt_ts duration rounded up to nearest minute.
#D      (OTPT:  myp.AT-DIST_REJECT_wfs.ps )
        cd $datDIR
        cd DAT_"$NVTID"
        cd DAT.TRMD

        set dstFN   = l.ranked.INFO_gp-stn.dist
        set LGampFN = dat.LRGampINFO
        set pLEN = 10.0
        set pLEN = \
          `caldate -f %M_%S_%F -d $eT $sT |\
          gawk '{split($0,a,"_");printf("%f\n",a[1]+(a[2]+(a[3]/10000.))/60.)}'`
        set lvotFN = dat.gp-select-fnl.OT.three
        set Vest = ` cat $lvotFN |gawk '{printf("%f",$6+0.)}' `
        set wfSPS = 20; 
     echo "WFs CONSIDER-RANKED LIST ## NORMALIZED"
        set DECIMATE = 10
        set DECIMATE = 5
        set DECIMATE = 2
        set DECIMATE = 4
        set wfSPSplt = `echo $wfSPS $DECIMATE |gawk '{printf("%d",int(($1/$2)+0.5) )}'`
        set durMsmp = ` echo $durM $wfSPS |gawk '{printf("%d",int( $1*60.*"'"$wfSPS"'" ) )}' `
        set shftOTsmp = ` gawk '{printf("%d\n", int(($14+0.)*"'"$wfSPS"'")  )}' $lvotFN `
        gawk 'BEGIN{FS=OFS="."}{\
          print $1,$2,$3,$4,$5,$6,$7,$8,"ascii";\
        }' plt.lst-rnkd-rjct.vlps.$$ > plt.lst-rnkd.wfs.$$
        /bin/rm pltdat.REJECT.wfs;  touch pltdat.REJECT.wfs
        set Smax = ` sort -k 7,7n  $dstFN |sed -n '$,$p' |gawk '{print $7+10.}'`
        foreach if (` cat plt.lst-rnkd.wfs.$$ |sed -n '1,$p' `)
          set if_shrt = ` echo $if |sed 's/ascii//' `
          set DC = ` $utl/mav $if |gawk '{printf("%lf\n",$6+0. )}' `
          gawk '{printf("%lf\n",($1-"'"$DC"'")+0. )}' $if \
            > tmpx.$$
          set Nsmp0 = `wc $if |gawk '{printf("%d", $1 )}'`
          gawk '{\
            if(6000+0 <= NR+0 && NR+0 <= "'"$Nsmp0"'"-6000){\
              print $0;\
            }\
          }' $if |sort -k 1,1n > tmp.trm-srtd.$$
          set Nsmp = `wc tmp.trm-srtd.$$ |gawk '{printf("%d", $1 )}'`
          set N2 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.02)+0.5) )}'`
          set N15 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.15)+0.5) )}'`
          set N98 = `echo $Nsmp |gawk '{printf("%d", int(($1*0.98)+0.5) )}'`
          set V2 = `sed -n ''"$N2"','"$N2"'p' tmp.trm-srtd.$$`
          set V15 = `sed -n ''"$N15"','"$N15"'p' tmp.trm-srtd.$$`
          set V98 = `sed -n ''"$N98"','"$N98"'p' tmp.trm-srtd.$$`
          set RNG = `echo $V98 $V2 |gawk '{printf("%f",$1-$2+0. )}'`
          set iS = `egrep "$if_shrt" $dstFN |gawk '{printf("%f",$7+0.)}'`
          gawk 'BEGIN{\
            is=sprintf("%f","'"$iS"'"+0. );\
            decim=sprintf("%d","'"$DECIMATE"'"+0. );\
            shft=sprintf("%f","'"$V2"'"+0. );\
            norm=sprintf("%f","'"$V98"'"+0. );\
            rng=sprintf("%f","'"$RNG"'"+0. );\
            if(rng+0. == 0.+0.){rng=1.0+0.};\
            shft_ot=sprintf("%d","'"$shftOTsmp"'"+0 );\
          }{\
     if(6000+shft_ot <= NR+0 && NR+0 <= 6000+shft_ot+"'"$durMsmp"'"+0 ){\
            if( (NR % decim) == 1+0 ){\
              printf("%lf %f\n",(-0.7*($1)/rng),(is+0.) ) ;\
            }\
     }\
          }END{\
            print "sss";\
          }' tmpx.$$ >> pltdat.REJECT.wfs
        end
        set addSHFT = -3.5; echo "For touch-ups only"
        set addSHFT = 0.0;  echo "STANDARD"
        set Vshft = 0.0;echo "(min.)"
        set Vshft = ` egrep -v '00A ' $LGampFN |gawk '{printf("%f",$2-5.0+"'"$addSHFT"'" )}' `
        "$utl"/mGplt.DISTvsAT.wfs  $Smax $pLEN $Vest $Vshft $DECIMATE pltdat.REJECT.wfs
        mv myp2 myp.AT-DIST_REJECT_wfs.ps


      endif
      if ( "$vuPLOTs" == "Y" ) then
        cd $vuPLTdir
        gv myp.CONSIDER-REJECT_AT-ORDER.ps
        gv myp.CONSIDER-REJECT_DIST-ORDER.ps
        gv myp.AT-DIST_CONSIDER_vlps.ps
        gv myp.AT-DIST_REJECT_vlps.ps
        gv myp.AT-DIST_CONSIDER_wfs.ps
        gv myp.AT-DIST_REJECT_wfs.ps
      endif
#DE===:: OPTIONAL ::
#DE===:: OPTIONAL ::



set runtff = `date +%Y.%j,%T`
set runtimeNVT = `caldate -f %H:%M:%S.%F -d -- $runtff $runt00`
echo "$NVTID  DONE :: RUNTIME:  $runtimeNVT"

end
# END GRAND LOOP
# END GRAND LOOP
# END GRAND LOOP



set runtff = `date +%Y.%j,%T`
set runtimeTOT = `caldate -f %H:%M:%S.%F -d -- $runtff $runt00`
echo "LAST NVT executed in GRAND LOOP: $NVTID"
echo "GRAND LOOP RUNTIME_TOTAL:  $runtimeTOT"

exit

#ZZZZZ






#DAI==S==AI, ACTION ITEMS
#DCONCL 150613:
#D      . Added safe guards for too few data
#D      . Added iteration capability
#D      . Found oscillations sometimes occur and lead to infinite loops during iterations
#D      . Added a maximum number of iterations procedure
#D      . Found if not oscillating max number of iterations was generally less than 15 (ie. 14 in test)
#D      . Found results tend to become unstable for larger Nit's (above 3 to 7) and greater iterations
#D          actually finding it is pretty sensitive to this if there are fewer data stations (i.e.,
#D          at high XCs)
#D          -- IN FACT, fewer Nits --> more rapid convergence, so less likely hood of spurious error.
#D      So will:
#D        + mnXC = Adaptive (between 0.7 and 0.6 w/ mnSTN == 18 as adaptive stop else 0.60 stop)
#D        + Mfs = 1.5
#D        + mxNit = 15
#D        + cutNit = Adaptive
#D        + mn,mxIQR == 1.0; 3.5
#D        + vel = (Adaptive, see Vest above) 
#D      Next:
#D        Try in this order:
#D DONE      + CONSIDER vs REJECT w/ moveout rank.
#D DONE      + MOVEOUT suite as a function of distance: (use "CONSIDER") probably
#D DONE          single panel figures to visually enhance moveout and probably
#D DONE          2 separate figures, one for vlps; one for wfs.
#D DONE      + Try the MAD instead of KURTOSIS method for selecting a portion of the nvt for XC above.
#D DONE      + !!! CONSOLIDATE ABOVE BEFORE MOVING ON TO second ERM PASS !!!
#D
#D          = DEMO FIGS: 
#D            . Add map start (basically LAG map w/ all gray colors and same size for each station)
#D                Useful as one of the DEMO Figs.
#D            . Add size (duration) scale to MAP
#D            . ??? Add 3-panel suites for wfs and vlps:
#D                 (e.g. Inst.-correct; normalized; Final sorted w/ move-out )
#D            . !!! Add 2-panel suite of vlps showing TRANSFORMATION of data from vlps to ptil suite !!!
#D
#D          = REPEAT ABOVE in PASS 2 PSERM for final  station selections
#D          + Select keep vs outlier stations to use for PASS 2 of determination of ERM
#D             . Thinking of using subset of "CONSIDERs" with higher XCs;  but always min of 7 ts
#D               to allow for the ptil ranking (better if significantly more than 7).
#D             . Add a kurtosis or MAD Filter to CONSIDER data; THIS WILL BE IMPORTANT for the Second Pass ERM
#D
#D          = FILT_VLP procedure for final XC alignments using:
#D             . refined selection of good stations after second grid search
#D             . limiting sweeps (window lengths in Fourier domain) to minimze
#D               chance of cycle skipping.
#D          = Formal BWR locations (No MTLB or 3-lg processing should be needed).
#D
#DAI==E==AI, ACTION ITEMS
#D
#D
#D
#D
#DNEXT --> Pass 2 --> Make REFINED psERM  (See: RM.v2.REFINED.PSERM.proc )
#D
#D
#D
#D
#D
